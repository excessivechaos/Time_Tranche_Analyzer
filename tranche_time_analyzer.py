import base64
import ctypes
import datetime as dt
import functools
import gc
import os
import json
import platform
import queue
import subprocess
import threading
import uuid
import webbrowser
from io import BytesIO
from typing import Tuple
import matplotlib
import numpy as np
import pandas as pd
import PySimpleGUI as sg
from dateutil import parser
from dateutil.relativedelta import relativedelta
from openpyxl.utils import get_column_letter
from PIL import Image, ImageTk
import yfinance as yf
from CSV_merger import main as csv_merger_window
import seaborn as sns

matplotlib.use("TkAgg")
import matplotlib.pyplot as plt

# make app dpi aware
try:
    ctypes.windll.shcore.SetProcessDpiAwareness(1)
except Exception:
    pass

__version__ = "v.1.14.6"
__program_name__ = "Tranche Time Analyzer"

if True:  # code collapse for base64 strings
    icon = b"iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAQIElEQVR4Xu2dX2hcdRbHz81MpkmbSZtp122aamttYesW/yCL4CJ2QbesLyJ92CdBkcr6B0EfFnGh4oOUgu3LIoIgiyI+6SI+lIKFRVYLXSnIUrRaLWxqV23axDQ17WRmcpd01zgz2Zj2l3PP72TuJ6/NPd/z+5yTD7fk5k6SpmkqfEEAArkkkCCAXM6dQ0PgMgEEwCJAIMcEEECOh8/RIYAA2AEI5JgAAsjx8Dk6BBAAOwCBHBNAADkePkeHAAJgByCQYwIIIMfD5+gQQADsAARyTAAB5Hj4HB0CCIAdgECOCSCAHA+fo0MAAbADEMgxAQSQ4+FzdAggAHYAAjkmgAByPHyODgEEwA5AIMcEEECOh8/RIYAA2AEI5JgAAsjx8Dk6BBAAOwCBHBNAADkePkeHAAJgByCQYwIIIMfD5+gQQADsAARyTAAB5Hj4HB0CwQL428gRuTQ9BUEIQCAiget6B+WX/ZuDOwgWwO5P/yzjtYngYC6EAAQWT+COyq3y+/W/Cy6EAILRcSEE4hNAAPFnQAcQiEYAAURDTzAE4hNAAPFnQAcQiEYAAURDTzAE4hNAAPFnQAcQiEYAAURDTzAE4hNAAPFnQAcQiEYAAURDTzAE4hNAAPFnQAcQiEYAAURDTzAE4hNAAPFnQAcQiEYAAURDTzAE4hNAAPFnQAcQiEYAAURDTzAE4hNAAPFnQAcQiEYAAURDTzAE4hNAAPFnQAcQiEYgmgD+8q+/yoX6ZLSDEwwBCIhs698iv/nZ7cEogl8JFpzIhRCAgBsCCMDNKGgEAvYEEIA9cxIh4IYAAnAzChqBgD0BBGDPnEQIuCGAANyMgkYgYE8AAdgzJxECbgggADejoBEI2BNAAPbMSYSAGwLBAnjq9CEZa1xycxCNRv7081/LlmUDc0qlskdEGhoRbmok8qiIrJ7tp/rhITm/9xk3/Wk0Utxyowzse72l1InqqLzw7WGN8m5qVAo9sn/o7qB+EEATNgSAAIJ+iiJfhACUBoAAEIDSKpmWQQBKuBEAAlBaJdMyCEAJNwJAAEqrZFoGASjhRgAIQGmVTMsgACXcCAABKK2SaRkEoIQbASAApVUyLYMAlHAjAASgtEqmZRCAEm4EgACUVsm0TBQBvHT2qEw0pkwPmnXYA5VtMtRdnhOTypsd+CTgfSLSP3vW2rGj8v2br2SN2LR+Yf0GKT/2bEvmV7UJeWP0mGkfWYeVCyV5fM1tQTHBTwIGpXERBCDgigACcDUOmoGALQEEYMubNAi4IoAAXI2DZiBgSwAB2PImDQKuCCAAV+OgGQjYEggWwBfVManLtG23GadtKK2U3qQ4J+Wz6qikkmacblt+U2mVlJJCU+jMx7yN2DaReVpJRAbbUqoi8k3mybYBM3NcHxQZLIA8vRFo1/ABqXWY7Pas2y6Dxb6mpflUUnk7aIn8XjQoiTzc1t4pSeU1vy0HddYviTwZdCUCaMI235OACCBotxxchAAWGgICQAD/I8AdwEI/LH7/nTsAldlwB8B/AVQWybwIAlBBjgAQgMoimRdBACrIEQACUFkk8yIIQAU5AkAAKotkXgQBqCBHAAhAZZHMiyAAFeQIAAGoLJJ5EQSgghwBIACVRTIvEkEABydOysXpuvlRswy8q+9aqRR650S8O35CGh32KPA95Y3S1zXzqOwPX2cllU+yxGteO5GZtzvd2pZ7XlL52LyXLAMTWSYitwdFBD8IFJTGRRCAgCsCCMDVOGgGArYEEIAtb9Ig4IoAAnA1DpqBgC0BBGDLmzQIuCKAAFyNg2YgYEsgWADnHrpXps+dse0247RVe1+V7q03z0nJw/sAPpr8WmY+7KWTvq4vrZTn1t7ZdiReCNIMBAE00UAACGBpCjDCg0DcASzNVfmh6/ZXgnEHsJTniQBUpscdAHcAKotkXgQBqCBHAAhAZZHMiyAAFeQIAAGoLJJ5EQSgghwBIACVRTIvggBUkCMABKCySOZFEIAKcgSAAFQWybwIAlBBjgAQgMoimReJIIDze5+R6fEx86NmGVj+wx+lcN0NcyJePHNE6mlnfQ7iI2tuaXn5yfHqOXnnu8+zxGtee233CnmwclNb7oikctC8l2wDl0siO4Migp8EDErjIghAwBUBBOBqHDQDAVsCCMCWN2kQcEUAAbgaB81AwJYAArDlTRoEXBFAAK7GQTMQsCWAAGx5kwYBVwSCBTDz9piJxpSrwyy2mQcq22Soe+bDJFq/xnc/IWm9ttjyrq7vf/p56VqzdrYnngNwNZ6rbCbCcwBPnT4kY41LV9mo72+f76PBRnbeIVLrLNlVXn5LCkMbZwfCC0F87+ZPdxfhSUAEsJQXRgQBLO35tXaPAFSmyR0AfwugskjmRRCACnIEgABUFsm8CAJQQY4AEIDKIpkXQQAqyBEAAlBZJPMiCEAFOQJAACqLZF4EAaggRwAIQGWRzIsgABXkCAABqCySeREEoIIcASAAlUUyLxJBAOZnJBACEFAnEPy3AOqdUBACEDAngADMkRMIAT8EEICfWdAJBMwJIABz5ARCwA8BBOBnFnQCAXMCCMAcOYEQ8EMgWAB5eh/AruEDUpPO+mSgPeu2y2Cxb3YTqx8ekplPe+qkr+KWG2Vg3+stRzpRHZUXvj3cSceUSqFH9g/dHXQmBNCEbb4HgRBA0G5FvwgBLDwCBIAALhPgDmDhHxav38EdgNJkuAPgvwBKq2RaBgEo4UYACEBplUzLIAAl3AgAASitkmkZBKCEGwEgAKVVMi2DAJRwIwAEoLRKpmUQgBJuBIAAlFbJtAwCUMKNABCA0iqZlokigDx9NuCLZ45IPe2sJwEfWXOLVAq9s4taO3ZUvn/zFdPFzTqssH6DlB97tiXmq9qEvDF6LOto0/rlQkkeX3NbUGbwg0BBaVwEAQi4IoAAXI2DZiBgSwAB2PImDQKuCCAAV+OgGQjYEkAAtrxJg4ArAsEC+KI6JvUO+xv5DaWV0psU/8+AhkUkdTW4xTezTkS6Z8uk42NSH/5y8WUdVUh6V0hx89aWjibTugxPjTvqcvGtFKVLNi8bCCoULIA8vRAklT0i0ggC7PWiRB4VkdWz7fHnwF4ntXBfUZ4DQAALD8bzdyAAz9O5ut4QwNXxmve753sSkDsAJcDGZXgj0MLA+S9AEyMEwKPAC//I+PsO7gCUZoIAEIDSKpmWQQBKuBEAAlBaJdMyCEAJNwJAAEqrZFoGASjhRgAIQGmVTMsgACXcCAABKK2SaRkEoIQbASAApVUyLRNFAAcnTsrF6brpQbMOu6vv2paXZPyY93dJO+xR4ER+JSI/vhCkMXxSLn3wXtaITesXVl8jPTvub8kcbVyU9y+cMu0j67DlXUXZUd4UFBP8HEBQGhdBAAKuCCAAV+OgGQjYEkAAtrxJg4ArAgjA1ThoBgK2BBCALW/SIOCKAAJwNQ6agYAtgWAB5OnXgO+On5BGh/0a8J7yRunrKjVt21lJ5RPb7cs4LZGyiNzalnJeUvk442Tb8oksE5Hbg0KDBZCnF4LsGj4gtQ57/dmeddtlsNjXtDSfSipvBy2R34sGJZGH29o7Jam85rfloM76JZEng65EAE3Y8vzRYCIIIOgnyMVFCEBlDAiAOwCVRTIvggBUkCMABKCySOZFEIAKcgSAAFQWybwIAlBBjgAQgMoimRdBACrIEQACUFkk8yIIQAU5AkAAKotkXgQBqCBHAAhAZZHMiyAAFeQIAAGoLJJ5kQgCyNOHg35WHe24NwJtKq2SUlJoWtVJERkxX91sA2cedR5si6iKyDfZxppXn5nj+qDU4CcBg9K4CAIQcEUAAbgaB81AwJYAArDlTRoEXBFAAK7GQTMQsCWAAGx5kwYBVwSCBVA//k9Ja1OuDrPYZoo3/EKS5c1/I//finn4LcDE9JScrk0sFqGr63uSomwsreS3AD8xlWABnHvoXpk+d8bVwBfbzKq9r0r31pvnlMnDC0E+mvxaXjp7dLEIXV1/fWmlPLf2zraeeCFIMxAE0EQDASAAVwa74mYiPAjEHcAVT8flN7a/Eow7AJdjusKmEMAVgvrpb+MOgDsAlUUyL4IAVJAjAASgskjmRRCACnIEgABUFsm8CAJQQY4AEIDKIpkXQQAqyBEAAlBZJPMiCEAFOQJAACqLZF4EAaggRwAIQGWRzItEEMDFd96Q6cnvzY+aZWDvb++TrjVr50Tk4bMBT9cuyD8m/50lXvPaA4Ue2d53XVsunw3YDCT4SUDzaRIIAQioE0AA6kgpCIGlQwABLJ1Z0SkE1AkgAHWkFITA0iGAAJbOrOgUAuoEEIA6UgpCYOkQQABLZ1Z0CgF1AsECeOr0IRlrXFJvKGbB+T4ZaGTnHSId9vqzystvSWFo4yxu3gcQc/MWmx3hQSAEsNihxb0eAcTlr5uOAFR4cgfAo8Aqi2ReBAGoIEcACEBlkcyLIAAV5AgAAagsknkRBKCCHAEgAJVFMi+CAFSQIwAEoLJI5kUQgApyBIAAVBbJvAgCUEGOABCAyiKZF0EAKsgRAAJQWSTzIhEEMPM5chONzvpw0Acq22SouzxnfOO7n5C0XjMfa5aB/U8/3/L2o+PVc/LOd59nGWlee233CnmwclNb7oikctC8l2wDl0siO4Migh8FDkrjIghAwBUBBOBqHDQDAVsCCMCWN2kQcEUAAbgaB81AwJYAArDlTRoEXBFAAK7GQTMQsCUQLIAvqmNSl2nbbjNO21BaKb1JcU7KZ9VRSSXNON22/KbSKiklhdnQdHxM6sNf2jaRcVrSu0KKm7e2pEymdRmeGs842bZ8Ubpk87KBoNBgAeTphSC7hg9IrcNkt2fddhks9s0uTfXDQ3J+7zNBS+T1ouKWG2Vg3+st7Z2ojsoL3x722nJQX5VCj+wfujvoWgTQhG2+JwERQNBuRb8IASw8AgSAAC4T4A5g4R8Wr9/BHYDSZLgD4L8ASqtkWgYBKOFGAAhAaZVMyyAAJdwIAAEorZJpGQSghBsBIAClVTItgwCUcCMABKC0SqZlEIASbgSAAJRWybQMAlDCjQAQgNIqmZaJIoCDEyfl4nTd9KBZh93Vd61UCr1zYt4dPyGNDnsU+J7yRunrKs2etTF8Ui598F7WiE3rF1ZfIz077m/JHG1clPcvnDLtI+uw5V1F2VHeFBQT/CBQUBoXQQACrgggAFfjoBkI2BJAALa8SYOAKwIIwNU4aAYCtgQQgC1v0iDgigACcDUOmoGALQEEYMubNAi4IoAAXI2DZiBgSwAB2PImDQKuCCAAV+OgGQjYEkAAtrxJg4ArAgjA1ThoBgK2BBCALW/SIOCKAAJwNQ6agYAtAQRgy5s0CLgigABcjYNmIGBLAAHY8iYNAq4IIABX46AZCNgSQAC2vEmDgCsCCMDVOGgGArYEEIAtb9Ig4IoAAnA1DpqBgC0BBGDLmzQIuCKAAFyNg2YgYEsAAdjyJg0CrgggAFfjoBkI2BJAALa8SYOAKwIIwNU4aAYCtgT+AxBxhcTqHAGHAAAAAElFTkSuQmCC"

    checked = b"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"
    unchecked = b"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"

    donate_paypal_logo = b"iVBORw0KGgoAAAANSUhEUgAAA1IAAAE4CAYAAABR1sISAAAgAElEQVR4XuxdB5xcVdU/Mzs727KbHtILJYQeeu8CCoigIioqIFIFBEEUkE8FQWwgCAoIgiCCYKGD0ov0GhJqSIWEkF6278x85/Z737zZ3dmSnWz+jx/ZKW/Ou/d/zz33tHtugnABASAABIAAEAACQAAIAAEgAASAQFEIJIq6GzcDASAABIAAEAACQAAIAAEgAASAAMGQAhMAASAABIAAEAACQAAIAAEgAASKRACGVJGA4XYgAASAABAAAkAACAABIAAEgAAMKfAAEAACQAAIAAEgAASAABAAAkCgSARgSBUJGG4HAkAACAABIAAEgAAQAAJAAAjAkAIPAAEgAASAABAAAkAACAABIAAEikQAhlSRgOF2IAAEgAAQAAJAAAgAASAABIAADCnwABAAAkAACAABIAAEgAAQAAJAoEgEYEgVCRhuBwJAAAgAASAABIAAEAACQAAIwJACDwABIAAEgAAQAAJAAAgAASAABIpEAIZUkYDhdiAABIAAEAACQAAIAAEgAASAAAwp8AAQAAJAAAgAASAABIAAEAACQKBIBGBIFQkYbgcCQAAIAAEgAASAABAAAkAACMCQAg8AASAABIAAEAACQAAIAAEgAASKRACGVJGA4XYgAASAABAAAkAACAABIAAEgAAMKfAAEAACQAAIAAEgAASAABAAAkCgSARgSBUJGG4HAkAACAABIAAEgAAQAAJAAAjAkAIPAAEgAASAABAAAkAACAABIAAEikQAhlSRgOF2IAAEgAAQAAJAAAgAASAABIAADCnwABAAAkAACAABIAAEgAAQAAJAoEgEYEgVCRhuBwJAAAgAASAABIAAEAACQAAIwJACDwABIAAEgAAQAAJAAAgAASAABIpEAIZUkYDhdiAABIAAEAACQAAIAAEgAASAAAwp8AAQAAJAAAgAASAABIAAEAACQKBIBGBIFQkYbgcCQAAIAAEgAASAABAAAkAACMCQAg8AASAABIAAEAACQAAIAAEgAASKRACGVJGA4XYgAASAABAAAkAACAABIAAEgAAMKfAAEAACQAAIAAEgAASAABAAAkCgSARgSBUJGG4HAkAACAABIAAEgAAQAAJAAAjAkAIPAAEgAASAABAAAkAACAABIAAEikQAhlSRgOF2IAAEgAAQAAJAAAgAASAABIAADCnwABAAAkAACAABIAAEgAAQAAJAoEgEYEgVCRhuBwJAAAgAASAABIAAEAACQAAIwJACDwABIAAEgAAQAAJAAAgAASAABIpEAIZUkYDhdiAABIAAEAACQAAIAAEgAASAAAwp8AAQAAJAAAgAASAABIAAEAACQKBIBGBIFQkYbgcCQAAIAAEgAASAABAAAkAACMCQAg8AASAABIAAEAACQAAIAAEgAASKRACGVJGA4XYgAASAABAAAkAACAABIAAEgAAMKfAAEAACQAAIAAEgAASAABAAAkCgSARgSBUJGG4HAkAACAABIAAEgAAQAAJAAAjAkAIPAAEgAASAABAAAkAACAABIAAEikQAhlSRgOF2IAAEgAAQAAJAAAgAASAABIAADCnwABAAAkAACAABIAAEgAAQAAJAoEgEYEgVCRhuBwJAAAgAASAABIAAEAACQAAIwJACDwABIAAEgAAQAAJAAAgAASAABIpEAIZUkYDhdiAABIAAEAACQAAIAAEgAASAAAwp8AAQAAJAAAgAASAABIAAEAACQKBIBGBIFQkYbgcCQAAIAAEgAASAABAAAkAACMCQAg8AASAABIAAEAACQAAIAAEgAASKRACGVJGA4XYgAASAABAAAkAACAABIAAEgAAMKfAAEAACQAAIAAEgAASAABAAAkCgSARgSBUJGG4HAkAACAABIAAEgAAQAAJAAAjAkAIPAAEgAASAABAAAkAACAABIAAEikQAhlSRgOF2IAAEgAAQAAJAAAgAASAABIAADCnwABAAAkAACAABIAAEgAAQAAJAoEgEYEgVCRhuBwJAAAgAASAABIAAEAACQAAIwJACDwABIAAEgAAQAAJAAAgAASAABIpEAIZUkYDhdiAABIAAEAACQAAIAAEgAASAAAwp8AAQAAJAAAgAASAABIAAEAACQKBIBGBIFQkYbgcCQAAIAAEgAASAABAAAkAACMCQAg8AASAABIAAEAACQAAIAAEgAASKRACGVJGA4XYgAASAABAAAkAACAABIAAEgAAMKfAAEAACQAAIAAEgAASAABAAAkCgSARgSBUJGG4HAkAACAABIAAEgAAQAAJAAAjAkAIPAAEgAASAABAAAkAACAABIAAEikQAhlSRgOF2IAAEgAAQAAJAAAgAASAABIAADCnwABAAAkAACAABIAAE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TNccjUZtJJP+7tYbHLrBWDjTb9sQ1/UOWj6qdDTv9ASNFvL0PVNtlpP8mqrKr508d9jycVi9yXN76x9t+c39PZrfcdVrxjxeOxJzZ9YvnR69//pvp79pVdmdnYfz3NY8Nr3+O2zGGaflo5lLm/fOLiv5/bP19qxTd/5IM//t901T81i+X2jrRy/Pv0/T/LK/X7MubWrm/ubtR9tCkpffPL7e1PK733Kc188HjXH67zR++/Vieo49ql8z/+03TdOPtW0/GofZ9V8znelncZ5b/89uP7a2+/uu/xu/dN2oQ7cfL7o9quex1JRmunvb3WradNav2T7O9vuo26PRXP5FzPbbxsbk80bbbTg82vb32OqlD0B5msaP95++QX+rfuKg9UHb8ps+YYW2H/X6L63Dpufn9JM5u+ustvmvs5VOXdq5TW/fm/m5259/ut0fbox6owdzgzfubQ7PfzFYXPxyeXn5YQpLR2taW1M93yrQusJtreAFBAgQIECAAAECBAgQKExAkCqs4YZLgAABAgQIECBAgEBcQJCKG6pAgAABAgQIECBAgEBhAoJUYQ03XAIECBAgQIAAAQIE4gKCVNxQBQIECBAgQIAAAQIEChMQpApruOESIECAAAECBAgQIBAXEKTihioQIECAAAECBAgQIFCYgCBVWMMNlwABAgQIECBAgACBuIAgFTdUgQABAgQIECBAgACBwgQEqcIabrgECBAgQIAAAQIECMQFBKm4oQoECBAgQIAAAQIECBQmIEgV1nDDJUCAAAECBAgQIEAgLiBIxQ1VIECAAAECBAgQIECgMAFBqrCGGy4BAgQIECBAgAABAnEBQSpuqAIBAgQIECBAgAABAoUJCFKFNdxwCRAgQIAAAQIECBCICwhScUMVCBAgQIAAAQIECBAoTECQKqzhhkuAAAECBAgQIECAQFxAkIobqkCAAAECBAgQIECAQGECglRhDTdcAgQIECBAgAABAgTiAoJU3FAFAgQIECBAgAABAgQKExCkCmu44RIgQIAAAQIECBAgEBcQpOKGKhAgQIAAAQIECBAgUJiAIFVYww2XAAECBAgQIECAAIG4gCAVN1SBAAECBAgQIECAAIHCBASpwhpuuAQIECBAgAABAgQIxAUEqbihCgQIECBAgAABAgQIFCYgSBXWcMMlQIAAAQIECBAgQCAuIEjFDVUgQIAAAQIECBAgQKAwAUGqsIYbLgECBAgQIECAAAECcQFBKm6oAgECBAgQIECAAAEChQkIUoU13HAJECBAgAABAgQIEIgLCFJxQxUIECBAgAABAgQIEChMQJAqrOGGS4AAAQIECBAgQIBAXECQihuqQIAAAQIECBAgQIBAYQKCVGENN1wCBAgQIECAAAECBOICglTcUAUCBAgQIECAAAECBAoTEKQKa7jhEiBAgAABAgQIECAQFxCk4oYqECBAgAABAgQIECBQmIAgVVjDDZcAAQIECBAgQIAAgbiAIBU3VIEAAQIECBAgQIAAgcIEBKnCGm64BAgQIECAAAECBAjEBQSpuKEKBAgQIECAAAECBAgUJiBIFdZwwyVAgAABAgQIECBAIC4gSMUNVSBAgAABAgQIECBAoDABQaqwhhsuAQIECBAgQIAAAQJxAUEqbqgCAQIECBAgQIAAAQKFCQhShTXccAkQIECAAAECBAgQiAsIUnFDFQgQIECAAAECBAgQKExAkCqs4YZLgAABAgQIECBAgEBcQJCKG6pAgAABAgQIECBAgEBhAoJUYQ03XAIECBAgQIAAAQIE4gKCVNxQBQIECBAgQIAAAQIEChMQpApruOESIECAAAECBAgQIBAXEKTihioQIECAAAECBAgQIFCYgCBVWMMNlwABAgQIECBAgACBuIAgFTdUgQABAgQIECBAgACBwgQEqcIabrgECBAgQIAAAQIECMQFBKm4oQoECBAgQIAAAQIECBQmIEgV1nDDJUCAAAECBAgQIEAgLiBIxQ1VIECAAAECBAgQIECgMAFBqrCGGy4BAgQIECBAgAABAnEBQSpuqAIBAgQIECBAgAABAoUJCFKFNdxwCRAgQIAAAQIECBCICwhScUMVCBAgQIAAAQIECBAoTECQKqzhhkuAAAECBAgQIECAQFxAkIobqkCAAAECBAgQIECAQGECglRhDTdcAgQIECBAgAABAgTiAoJU3FAFAgQIECBAgAABAgQKExCkCmu44RIgQIAAAQIECBAgEBcQpOKGKhAgQIAAAQIECBAgUJiAIFVYww2XAAECBAgQIECAAIG4gCAVN1SBAAECBAgQIECAAIHCBASpwhpuuAQIECBAgAABAgQIxAUEqbihCgQIECBAgAABAgQIFCYgSBXWcMMlQIAAAQIECBAgQCAuIEjFDVUgQIAAAQIECBAgQKAwAUGqsIYbLgECBAgQIECAAAECcQFBKm6oAgECBAgQIECAAAEChQkIUoU13HAJECBAgAABAgQIEIgLCFJxQxUIECBAgAABAgQIEChMQJAqrOGGS4AAAQIECBAgQIBAXOC/NskxdOHM8ysAAAAASUVORK5CYII="
    donate_venmo_logo = b"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/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAATABJREFUeNrs3XmcFNW9NvDnVHX3rOzLyCYCAiKKIqKiEAQ1oEZvNMaAMV5fRcOLJhpNNJvmRrNpLhq96lUvZvEmYNwS14govARlkcgq+yayDzAwMMMs3VXn/aO7Z6qrq6qru6q3mef7+SizdFdXVy9TT//OOT8hpQQRERERERERACg8BERERERERMSQSERERERERAyJRERERERExJBIREREREREDIlERERERETEkEhEREREREQMiURERERERMSQSERERERERAyJRERERERExJBIREREREREDIlERERERETEkEhEREREREQMiURERERERMSQSERERERERAyJRERERERExJBIREREREREDIlERERERETEkEhEREREREQMiURERERERMSQSERERERERAyJRERERERExJBIREREREREDIlERERERETEkEhEREREREQMiURERERERMSQSERERERERAyJRERERERExJBIREREREREDIlEREREREREDIlERERERETEkEhEREREREQMiURERERERMSQSERERERERAyJRERERERExJBIREREREREmQrwEGTftmaM33dc9jlYL7rXNKBbTb3serRJdK5tlB1PNIuKE2GUN4VRGtYRgAAgASF43IiIiIionVMAFYiUBtBYpqKxQylqK0Oo61KBo13LUNOzEgd6VOBQVUfsG6BgEQ8YQ2LBWd+ISVsOycHbasSgXTU4+bP9OPPgCdmjPiwq6xsQOB7W0ajpiDTrQFgAYR3QAGgSkAB0IB4SiYiIiIgYEmP/CgCqAFTE/lMgSgQqAgoqQgrKS6B3KEFdp1IcOaM3PhvcFVsGdse2od2xaUgJNivATh5M94SUTCSZqK7DqI2NGPZZNYav3SvPWrEbow7Wo3tNg67UNurACQ1oRGviU0T0S4FYmTD2DQf8EhERERG5oxu+loYvdMPPSgRQrqK8TEG3MgVdy3B0ZG+sHNUPy0f0wdqRXfBpB2ADDyZDoi9WHZNXr9mPEZ/swuglO8XYfcfQ9WB9BJG6CNCE1jCoxJ6gSjwVojUUJv1rfDTAKiIRERERkR9BUgLQYyP2QgKoVNGtMoCeHXBi7MlYNGYAFo85GUtOK8FGALt44BgSXfvXMXntv3Zj1AebcdmqfWLk3lot0HBMAxr1aKlbV6JhUAXQciwNwVAiWjmU0lBBRHJAJCIiIiKi7AVHGTs/16OhUXRU0bdjAMOrsOHK0/DWuEH451nlWMPAyJBoaf1ROemTg2L03I3yik92ifN3HQ0r4VodCMvoWOiEYaISLSvNGIuE8W+kNOVBm3DIKiIRERERUW5Doy6j5/UdAzipcwDn9cXqrw7H6xcPxoIBCj5vr4GRITFme40cv7kJQxduwfi3NuPqzw/rlfW1kei8QhXRYaQtlUFTshOIVRGFdUiM/9xqiClDIhERERFRfmmxwBgUUDuq6NMpgGvPxOtXD8cbE7pjQXsLi+0+JG49LCf86yhG/+0zXPvRTpy/90gEOK619qBQzCnOIs21hEQkhkDJXhZEREREREXDWGEsU9Gpm4qxpyhrbxyJP185AG+1lwVv2m1I3HxIXrLooPzSnJVi6qd7MPjokWagWUYrhsKcBc1zCSUgBSD0xKRoFxajiRGsIhIRERERFVNgjE43K+mi4syTAoduuwDPXnsaXu8OrGRIbEM2HZSX/PMgLv7fT/GtFXvRv76muXUFJMVNgjN+L1sXpUkIgIYFa1I+AoYMSUREREREBRgWY6fuXVSM6B04eucYPHnNaXi9G7CaIbGIbaiWl604jlF/+gQ3L/1CH3q8JhJ9wOPB0HZoqEUVESL6bEkIiKZ2F+mERAZEIiIiIqLCp8VO4buqOLdvoPqusXj8GwPx1wCwgyGxiKzdLy/fGRED5qzQb5i7SVx0+HBz9MF1amJvDH/m1UlbsqBV30Nj8nP7CDAkEhEREREVXVgUQKiLii+fFlh754V4ctJJmIs2ssBNmw6Jy/bp1/1tq7hm9gp5w65DGtCgxVpYmMMgEguBLcEtHhJlLFUaqojmgBhvgQFwwRoiIiIiovYSFkMKOnRVceto5fXpF+CZoSX4kCGxAK3aq1+9+rgY8V+L5V0rdund5fFwNOQpbo6IRRWxZeioYS6iVbsLGEJiS9sLp9sy5E0iIiIiIio+8QVuygMY1CcQ+ekl+PnNp+JPKOKqYpsLiYv2yhv+vBY3vbZWTjp8sLl13qE0rD4qRGLYs0twLSFRxKqJFkHRdvEaCy4uQkRERERExRsW1a4BTB0ZWPT9L+GRsyqwphjDYpsJiSv2yK+uPS7PePIjfG/Fbq0r6rTWdhZW4Sw+PFRIw7o0VsNPhcWjL+xDotsgyLmIRERERERtjwagRMHJvYJ4eDIeuKkIq4ptIiR+ukd+9a9b8Y0/LZdTqg82tw4PtVp4NIFpIqKxz2FCSIwPH5XJw0tbriPSqxQyJBIRERERtU3xqmKXAO4YG/j7D8bj0b7AEobEHPnHHnn7f38sZ7y3RT8rfFSzbmmRYlRpyyI1Vq0ujKubJs1BNC9YY7gcAyIRERERUfumAShTMO604M5fTcaPx3bDIhRBVbFoQ+Ly3fLaDSdw+q8+wE827QmXolmPDi+1TGs2qSypzyFsQqIwfCQgTBczXF+KlDfJkEhERERE1I7oAFSgc88gnrxa+cm3TsX/FnpQLMqQ+Mkued0H+3HJf32M6fv3NkUDl4LEYGgOYo5DQVNUEY1zFRM2ZLqOFFyYhoiIiIiIkoOiJqF2D+DBywKz7h+N35QA2xgSfbJsl7zuL5vkN//4qf7V44ciprYWwj7/xbNdQuCzCYwiFviMQ01bwqZx+KlIHH7qZk6iOV8SEREREVH7oAGoVHDrhcF5D38ZP+kFLGdI9OifX+g3PrcS01/5TL8ofDQeEI39CePfulxBJqn/oV3CNKY684qmDgGViIiIiIjIHBTLFFw5Mrj2P6/EvaeVYB5DYobe/1yf9sRy3P3uOm046jWH+YdIDo12mTEh6FmFxfjCN7I1fLb0TYTpum6POFhFJCIiIiJqz3QAIeDC00v2PHk17hzVAX9nSEzTO5/L6TM/kt9fsFkbhAatddio7dBR88qkwkVAExap0jSp0bjQTdJKpwyIRERERESURlBUFYwYHDz27Ndw25jOeJkh0aU3P5d3PrIQP1y8NdIHjbppDqJLVjkuoY+itE50CXMSpcV1XLTYcNwJIiIiIiJq10FRAYYMLGn+n+tx65e64M8MiSm8tUPO+M0/8ePFmyJ9EJaAksa+pspkxv6GcBpyagyI5o1Kw1VTBEBWEYmIiIiIyCooAjh1YEnkD1Pw72O7YHa+d0kp1GP17g45/dFF8oeLN4f7QDMGRFNIs0yH0jqkJVzMMM/QfIF0w5zV4jfCYreIiIiIiIjMiUwBtm5vCkx/Dc99cgzXMSRaeH+bPu2JZbj7oy1aP0TMgcui6X3SKqPCOaRZVv0M4VIYt2GuItr1SxQOoVAyJRIRERERkWMyW7elqfL//h3PrT2ByxkSDRZs0296biWmv78xMhSNukUINKcwi8aDLTlO2mRBi1VMpSFgphPqhNt5hpyPSEREREREDnRgxfpw1++9iSe+0HERQ2IsIM7ejBv/ti4yCif05D6ISYHPUPkTSnKATApwpgqjMSwmDBkVpsVpnP5lQCQiIiIiIp/SmabjwzVNg+97F789Bgxv1yFx/lb95vd3Y9JfVsjLZJ2xdYU5iMnWkGY3DNWpupe00Ex8KKk0bd/wvYR1IJQO7TIStkdEREREROQyoYWBvy5pGvPQP/EggH7tMiR+uFW/+bPjGP78ctzQcCxi2CvjENJ4dVCxDl/S5t+Wb2JBTpi2Z5MzW4afxucnxgOlMVgmBFnhLqQSERERERGlSmlNwMz54euf+Qwzch0UCyIkHgK6/+dCfL/mQNjwU2M4M1b1pEVoM13N8YfmBWYMYU/YbiAN0jC/kb0RiYiIiIgoAyqAYzrufCPyw7n7MKldhcT3t+rTnl6MO3ft11pDnLBbPMYc9hyGdCbMPRQWLS9SMa6cahpSKmXiHEbjcFSZzm0QERERERHZCALykIbvvYMnNoVxSbsIifO26Le8sgnXL9oe6Q+pA4owBC1TBU5YrGJqrihKu3BmGGaatF1z4DTehoBlFVKYgqRx34xfMysSEREREZEXIWDDlqbyn8/FzyPAgDYfElfVYuRLq3EZ6p2GZUo4DhdNmcQMw0glTENKLVY/ta1OGudHmlZCbdkwh5YSEREREZHPdGDOsvBFT67Cd5GD+Yl5C4mvbdHvfnaJnFFXG45VEGVr5nI1LFQmBz3LBWNk4sWseiQmDCe1CKzG7Uqby1iFWi5gQ0REREREfqS2Bh0/fjdy90eHMa5NhsR5W/RbZq/Fjdv3aYr9HD6HxWniVzEGPofCX2ubC5j6IZovaFWxNIVRIUxDX80tMFLsNxERERERUbpUoOmQhgfm4hfZ7p+Y85A4d7M+bVkNzn9ngzYKmp7c61BK2FcRZWLYE8L5sim/NgZCc+CL/SeEqfroVOGUzIdERERERJQdQeD/fdY04InluBtZHHaa85DYCFH6wie4vem4bp+mpICrVV+EIZwlTS+0WnDGEPiSKpjCzQ1ZfG3R6oIL1hARERERUTY0A7+YF5m29CjGtImQOHezPu3VTfL6z/dHYkHQjrTIaIYqnTSFO/O2pNP2zPMFze02pMUcRLdYQqQipAEIS6BRAvUa0CABnYeFiIiIqCCpQHONhl/Ox0+RpWpiTkPi1gYMfmOdGIeIdBG0DENPdVPIEyIx+6XMZtKmipiiemjZdsMqfDIckoFu+K8QA2GzIRA2akAXFRPOLa3b/lBprf5f5Xrz46VhhBQGRSIiIqICDopvrwyf+cImTMvG5gO5uh/vbdJv/+tqfON4bRjJK4oaA6LVPECrIOYQ8oTTDwy3KWXikFWg9bZb9sFp6KtwETapTYU/idYPLaThZwCg69HvSxSgUo0+LZr1/Aw/1mPPby32taYDqoJAVQBfPyNw9PFLoPYsR4UQLR8UVcavGlShnN4nGFm/synAB52IiIioQNXr+O1C3HflULx9ErC8KEPishpx/sc7Iv0tVyE1V+ykTOxpKEyXB1K3lzBmN3PoTFkhTAcDYpsIfpCGEGh4esSDHwB0VCE6qqiqCGBYD9RdNwwNF58M9ZSOKC8NICAEVOOzNSIRCf4sHECTnoP7EAuEWmyfQwpKegZw88hA7UNfgtqjFOWGQNg51SbXzUBAPKAAjXqeu6kSERERkaUgsGlbU+mzn5RM/4/zsB/ArqIKif/YpN/+yhpcr5/QW9ObBCCkxQIz0jm8CVhc3upyhipfQqsM2Ro+ra4jE9IluApNG9FsDIF6a7iqUIGOCjqUqRjaQ2n+2lAcn3AKxJAuKOkQQkgVUA3hyqgShuqb5YtLIICgABrgX9DSAWixD1FaAqGKyl4h3HW+Un3veajoXIJyIVqexJ0yvamp5waPzlnS1JkvASIiIqICpQFPfIRbpo7A7KGlRRYS5+/FJev2RiqTU55DRU+4aFbvph2FOfwJQ3B0XDvHHBYtbp6K5sXz7S+X1j4wDqJHGUqDCgI2wS8EoJufNy0Unz5m0BGdQ9hBRddeIdw3Vjn8nZGoKA+i1HCpnn7u++x/Q+c5KxWgntVEIiIiooKkAkf3NuLZT0pnPP4lbIZP1cSsh8S3N+ozXluL69Bot2KpsJj/Z5rrFw90EqmHmTqFRcuEJ2Jn4MYgCUMbDtO+2N08i44FHBIlnr0884qaF0GhoBma94DYUYX+2xJpGM7aLRf7X1Iq0FTPpxARERFRwRICzyzWr731PGXWGT5VE7NeH/hwLy7ZcVBT7Ctw0lS1S0iRLXe89eJuexsafi9F8u21FAlTLU6TQRalgiNlftbq7FDm06u0TjPPzs2Jed8KHEaQzx8iIiKigqUAzdXNeH4JbodPLTGyGhLf3qDPeGc9voKwtJhLaA58KeYixiuOafUwlClTd3LolIktMiTHlxY9AeyqQ10+bvrLg5SjUH3YULOEJhHJ9f6P64NuKFXZDoOIiIiokKkCzy+LfHVTE4YUfEhcfEiO2VIdCdk2txdu5xbKpHyZ1EFDWoTQli+N/QxF68I1Upo2BgbCtkgRuOnN/Myq+/k4AKoPNx0QKP11JC8tKVQ2wiAiIiIq8PNdoKk6gj+twM3woZqYtRPntzfoM97bKK5A2BDypLESKKxDXUJwk9aZ0Xg9y5VKjT0Pzddz6r9oqipKF2NImSkLnwAWrm+qzMdND+yMSl9eZQoQORDJy+Hr0znAhWuIiIiICp0q8KfluLHah8UMs3bqt6Eew9bsk12Thqnp5tRmXBDGqrJnk8QE4Hp103hghNXw1hTDSQVTYNFTAByX+XqtBqDCn+GaSn7mVr7+NRz2ZcgsEREREWX1nHfvria8+hmuK8iQ+NZ6fcY/t2G81qCZ8pfdibqwGS4qUofF+HbNFUWh2N+WYyCMVz1l6/dclKb45TPrKz7duAr8fi0O5Xr3R/ZEZwRYSiQiIiIqeBrwvz4MOc3KmV8dULlwO86EbhWw4j8TyXMSzUU9aao2mjcmjT+zOBFPuL7V5EVhsW2Loa+O/RT5XCwKCqBLr70oMsynflXhhMC97+s9c37oBFQEBBevISIiIip0QWDpxqaTPqzGJQUXEj/ahS8dr4sYApRNha8lFArbk+Io3SEMCosAahUwgZSJzzgHsWUlVafKI5+HRUMAW4/geF5eq8Knl5kC1B4I5+34EREREVERaJCYswo3wEM10feQ+NZ6fcaizzEOurHthaFSCD1xPqE0h0KrRWgUQ69Dm6pj0oqp5t/Ft228omFeou31WCpsExSBb76J8nzcdKcKH19mzXl6PnK0KREREVFxCAj8/TP9siNA54I59dsZRv/11bIjNIuT2aSqoUyxAI2hZ6ES/94quInkwBn/uTTMMUzofWjFPNRUOE6jZH4sIgL415amUD5ueuoZOFLsC7+wkEhERERUJBTg8L4w3t6KqwomJK7YhVFag+aQ+6zmFVqEw6SVSGOnqiJWVbSsIqZziitbK5dC2IRPcHXTNvRiQV1+Uv2950H1pVdiVl6x7gS5uikRERFR8YhIvL0OVyPDIae+nnK+tV6fsXgnLoIuTSs6GoaRCmEdCO2qe/EgJx1TpXXqlIYhr8bbFdI6sJpvN2GOounusIpILvWtRHmxD9fUuWgNERERUfEICLyxMXL+IYnueQ+JezX02XpYK7VeQ9K8kIzd/EPzZawCnENYFHa3LZEwJ1EY+jNKm16JxmDJUFj88rTCqeJnr0Tkp1cin/5ERERExXXe23Qwgnk7cFlGGdPPfVm5GyO1Zov5gvGKXkIWk7Fho9Kmn72LYZ7G6yVU/oRpE8aA6ERYbNjiqjxjLk4CWFmNo6Oq0C33L1T/hi3rgK7meOCpxud8izuGK3jqpmBOb3PxJh0b9kY/G6htAO5dqPGBICIiopQnje9vxOQpAzBHCOzKS0h8c71254q9YhQ0aT1fEMYwB0MFL81g2BLYYgFTKNHtmDclDSuWStPqpcbqoTRVGBMCJ+cjtimKwHWvoduOGXnIp6p/ny2IfDwxOdy0xcDuuT/8Fw5VcOHQ1s8F7rki+tb9woIIdh6WeHg5HyAiIiIyUQU+3IIJuCKD02a/9iEiRGD9AdkTOpLnHRqHdppbWMgU/QjNgVM3Bk9jiS8WBKVo/dqxvYXpukm5VsC6TYf7PEuF9kIBPv+iKS837VuvRMSa2+caK4ktOpUVzr7cOiGAh64LQj5SgpevCWBiFd+YiIiIqDXp7drXhE+O4fy8hcT1tRhW36C3Vhycqole+g+aA2XCMFCX/SqkNIVB8w4b5jDaTZvkSXNxOpGfB66LX70S81AwkhI6InzCx3UsK8wg9vULVHx4Twgf3xLElAEMi0RERO1aPDI1SszfgkvyFxIPyOHRVU0d+hhapSvbcxljkEtnQqA5xZknQxqun+48MZ53tY0XTB7cPAKHirVXYn0EzdCAYl+h1S99uhT2G8GFQxXMmR7Ce1MDfLCIiIja+/luEPhoF8bpEv3T2YQvZxFvbdBnbDgghreubhFblMYqmElzoBOpA2DC0FSYwp9M7ptoMc0w+ciZLpQwb9G0bWo7FECTiKgCOT2D/s5ohB75QAEixTd37NdLEIaml/LJE3VS5+J4T5h0tooDAxTcNSeMl3awEkxt38QqgRtG2n+axUWfiKhdhUPDD5du14en+2m/byfKWw7Jzq0ZT9ikPNgkN2nxK+NCM8Lxjif+3NjmIh5YEeuNaJ6/aLvR1utbTX+k4qUCi/egdlzf3K5w2qvCh16JOhCqyn116OlP9A6sJLaq6lQ8Hxz17CQwZ3oIg18Nc3EbavMevjKQsMCT2dxVDIhE1I7CYTy3KEDNvjDW1peccVYldrrdpC+nfTsaMaC+KTYf0Vh5kzL5ZoQC2+phy3xDh5Mwaf7CLkDK5JBpdxTNq5+2VBH5nGt7LyKBqX/PfQuMaK9E4W1OoZR45iuB6lzve20Tw4VRRRHWVB+6LoiZ41U+eNRmzZqsOgZEADjWyONERO0sIMY1S3yyCxekde7qS0g8jIEtrS8sw5q0uBfSNH1QWNxhYRHUpClQmq4U78mYtHqpKQjKVEfTtC/S4YGg4qEAe3blZ4VTz3MSNeDmM9E15/sd5qclccW8eug9VwTwwGiWg6ltvi6njEk9yuJYA9/LiKgdkNbnoKv2YGQ6m/Fl7NqOIxgQbX3hlGxF4o5LQ/ISVmkMgOVG49c3zCkUhu0JF0nO2AdRGttlxHfQGDapzWnMz4mCUDwWpzUg13MpaxpxAmEfhsq2EcM89kh8ZamG6/8Wsf39kErgvrGtnybcOsHfh/uh64LYcqiZcxSpTfmfbwZdVfh3HubznojaaChMNS1OEVhzACM0if6qcDfk1POp31sb9Bmfx0NiqhQb/4UwhDW7oafSuCCNxfxE10fM8F88+EmZKtGmqDpSUctT4PHcKzGU+08tzv49yotxsZ1sGegxJKaqZGyuA6a9p7X8J+5vwp0vhrF4k3+PwS+vCfKBpDZj1mQVA11W+Lcc4h9zImrDQTHFue/6A3q/nJ4uCwDba2TnlvmHdn0FHXsjijTutdXcQXN8NrfZcKgwCvN1ReK+sprY9gggIhHJ9c12rVQyf8VpwFXnlxzN9T7vPhzJS2/GQtWpzNv1axvSv87T63Rc9Psw7nwxjOpa7ye5A6sEZk3m/EQqfg+MVtKqtlef4DEjovaQFi3aDSpAzf4wqoGeOQuJTUCorjG+aA2S5+4lrVYanx/odIfMjext+hw6Bs74kNLY3Ecpky8T/72bNhzG/EjFTQE+/Bw5D1y3jkR1xh86aBJvXIeOOX2bkZCS8xET9PXYI3G7h0rG0+t0jHuyGdsPeH9MpowJYEglH08qXhOrBO7/SnpV8fkH+H5GRG09IJpyi/G0pUli8yEMzVlI3N+MXjKh4b3FgjLC8HspkquLliuWmoaeOlYhpbuQ55oAW2C0YULg5rf07rm+2e+cgzKoGb7kdECI3A6UfW41jqBZZ+sLg14eQ+IGj8PdNtcBlz/f7LmiWFGaOPeRqNgC4pxbg2mtNOxHFZ6IqGizo4ymvm1HMDBnIbG6Dj2j68so1gvVxIOh4QTd8mvbOYIi1jbDIgPKFEckPsRUGCqTxsBpO++Qf0zaNAXYvyuc85vtUZ7hAjA60Gdw7vsu3P1epCvYVixBZam3kOhHJWNzHfDQG95HS7tZDZIoG7xUsacMEHhzRgg90+xXuv8o/64TUXtgKtaZBlJ+XoMBbrfk+SzhUL3oEV1kRpqa19sFQGl9f2yDokTCKqfCqqRnHIoqEq9q2e/QYt+SVliVieGW2pam3J8wKAJqS6/EdMJis8QXd0CD9yYa6R2iRp5UmVV1yvw9wc9KxtPrdNy+U8eI/pl/zldRGp3T9fDy7E86nTJA4NJYD7sJpzsvNLJ4k44Ne6P7NO294v+U4oHRCvp3E7jqHDUp2Gw/ILFgvYYPNukFs+JsfH/jHyTYVeteWarhWIN0te/xVXuH9VZw4VAFLyyIZPTYzpqsZrzi774jhfl+Zpwf7HTf4s8VAHj0Iw2b6/h+TEQpWLzt7TqC/jkLidX1MjoB0nyuktCgXibusDAMPbUaxykEoMvWy5lDprBqXeF0YITNqqZWgdYmlPN8uW1Ri+h2gyIaMHPo2VWoQaPelUNNE090KzwUdOt8buT9/EINT93k7QE6s68CZCkkPjBawZl9FXz9gvSeuhcOVVqaot86IYA1O3V8sE7HvQv9DYxTBgjMmR5K+3puA46bQDOwSmBgVQC3TgC+s0nHA+9E8jJvbtbk1gDnVvxxvXUCMKsReGlJJCG8xMOmVdBMdwGnmeNV3HiRmnb10GjS2Srk2em/jdY3Auf8tsm3UDaxSuCGkYrlhwZunivx10V1rcRbK7Q28UEKEflFOKRFASgCe2rRO2ch8WgjOrcsWiNg06tDJgZAxxVL40Ew+b4lf2PuaWixUqnlvgiH9CfBJU3bx+sorCEcVJHTfgBp90rUgO9eXnIEQJdc7ued78SGmjIktjinh7f3Bb+Huz29Tscjjd6C66gB/j/AsyarjhWodI3or2BEfwXfnhjAc/MjvoXFwd2z8z4/c7yKb09M//5fOFTBh0NDuPPFMJ5el/3q7sQqgekXqmmHeCsVpdHgEg/1qSrcR09I18+ldMOU3z7a6E/VbuZ4FV8d5b5dRyo9O4mWY/7YuxHfP0QhorYi8f1273H0CesYEFSwI+shsfYEOiWuHGrMfdI+zSb9yCL8tQQ9Y/JUYHl7ljsgYxVJ2Fctk3ZJMCi2B4rAXzeh9sbTkdMFbEJCQVM6E/2aJZ64JLcBUUroWpNUGBD9DRV7sjDc7d1VmqeT/IFVAkMq4ctJsJehgG6DyD1XBHDpcAXfe817xS0+pDJddivcDqkE/nB9MK1qnJWnbgoCWQyKE6sE7puoYtLZ2Rmc4GYItFO/wjuGK7hqhJK1/UvXx1u9PQ5+VEFTib8uvv5imMNQicg2IEIAh+r1SrcVAE9/zd7ZqE8/3oyOCXOsRAZvhFa9FaXdHZVJZ7TJVUS7xXHMNxYbsiocDiyHmrZNArh7bu5XOO2WTq9EHUD33J8onfEcgCY2RzTrXO7tJO9Yg/9vJLtqvG/Ta4X0juEKDvw4lNWAaA4hb84IYcoAb/vdsSyz63ewuN7EKoFF3w15Dohxj1wfzEqLklmTVXx4TyjvAWzFQfvn7T2TAgUTEOsbkfGc3SkDBFbPCOKeKwI5qYSO6K9g0XdDbG1D1E7PaZOzjLTMPodP6JDS3Zmo579o9Q1Ic1CNtA+HsJmD6BCK3d2OoUIpMtkWtTkKcHhv7lc4/c55OOy6SB2ROHxfMOefC6/fH1HAjJikU5m36+887P8bzvIvvD9Qo0/O/M/Ay9cE8NRNwZwPB6woBeZM9xYU+2TYzqSyNDkMZLLaZqr79+RV/oXuKQMEtt2TuyCfKnjZVbuGVMK34Zh++GhjZkM4Z45XMWd6yNPCUpno2UngH7eHQETtLCC6SY+xfyIN7t/XFK/7dSJ+Wy39D+2GagqbqGtOutI5vSki8ajEq4hSN2zf1CdDGravyxQJUcKyTyK1PXlY4fSWs1DiuleiEOhaipx+LvzB5ziKRo1zES309dgjseaE//vkVJHJdvhdPSPoy3w2L2bdHMLEKn/CnlsndRYJ4WvWzSHf5l8ajT1N9aUq9MBoBXOmhwomfB1wWOX3G8MK640nk6GmH98SrR7my8AqkbBiKhG154BoijcKgGbpbtYePJ8KSjRHYAiHVqHPlLRa+hRK02qjxhYXsB+2Ku1CnrANz7ah0HKoKZNhu5GHv6PdS1Hm6nY14CdfLanO9f5dOTvSmb0RrfXyGBI3HPL/fSUf84+GVALb7sl9lcRKRSnwP9/MbO0pY9hL6zZLRNYDYvy+fXuUtzepl68J4KHrggX1OqpzaK1zZt/CCYmZDDVdPSPo25BjL646hyGRqM2HQ/PISGnOSTaa3d+M4nUvI7pp+Gi8t6C0uhndOfUmtKmwGi5qFZtjlxXGABpb8TShDYdtzrX+hlmxXbzIGjU05fImFQEVSqxXopMTGn7xJfTM5b6FdYSbGySriD6HirhstTaob8ztcfjH7aGCGhI4sEpg5vj0T4ozHR5aURqdg5jNgBg3vHfmx/m9qYG8V3qtOPUrzMZqu5l6d1V6n5atnhEsiA9O4s/tB0bzjZyozQZEq3DY8gPhHHjS+OzL23BTAd06TEmHMKggaeiptLv3IjEVC6cjJVIf1YTeik4pUMB1LZaKlwL8fg2O5fx2U5236UCf08tzvlu9ntCDaOZkRL9DBQBU12bv/aQ+h8OmP74l6Ckgbj8g8cKCCIY+3IRLHmvGCwsivoTcGy9KLwxN9Bhy35yR/YAIAIN7ZfYn+uVrvC/+sniT3vJYifub8MKCCOau8j7MYLdNSCy0+YgLN+tpvS68BsRXlmp48NVwy7HenqfVe4mogMOh47oqdlkpxTQ+B54GzgshkgOh5RDPFMHM9r3MaoVRaX2Zlu2YWlhIaQqITjdovC7fYNv+C07ghx/oPWaMzO0nril7JTZo2H1nbg9FREf48CEtmLBSMfkWKvzukZgPsyarnobSvbJUw/V/i7R8v7lOYv57Gmav1DHnVm+L3/TsFK0muu0VN8xjOxOrgDh3lYbdRySmvadh1mQVE0733hOvKoNjMmuyt96H1bUSD70RSWrBEW/afscaPdqmI0O1DQ7vjffbD+wYUglseqDEt+dfobwu1uzUk1q6THtPA97TsO2ezKv2XudQE1GBBUTbcJj+RtyOGfN0OiilREgVLu4R3LXGkHZf21UcpcuN2f1e2JRpJTNie6AAxw/kfoXToHB42elAp1NyvzrdSU/oQUR0BkS7EOKxsLvvSPZCYnyOXDZNGSA8rYz5woKI7Qn6/AMSd83x/jq8YJD7J+/A7v4ds+paianPNmPynEhLkJr2noZBjzV7rgalW630+jhtPyAx7slmxx6NXo/ddpu5uanm1/atKLwWNF6P99xVGs56Jmw7FP2PiyIgonYeDl0HRLsCl+nnaXyG6Hl105KARQCUFokvYainQ5iTVrdiqAJK83hb4+I45l6JTmNzrbOs96RORaU59w90d6deiQ0ajnw/kNOd0iUihw9pYNsLe4M9nhgfy+K8Qa/DHp0qO3G/vCbzytGanXpLeLLz0g7peSjjhUMV16uBem1nYg5VL+2wfsn+5G/ewm86Q3GHVAJPTM38caqulbj8+eaUYc3rsct0ASev1V83z/N0eX1dTJ7jHAL/ukEvyPccIipiIffvpZ7rBhUBodsvNCpMWc+4Mql0TmmKKa21zEs09DxMaJnhUFk0BlQBOLfpcBEsqe3Iw7oO37XrlRirIoocPwFPelIPsIrozOv8nmxUMeLBwKtUvRZnjvc2bPJ7r7mrhvxxqff5bm5bKHQs8/4S234gdah6aYf0NOcynfmmT17lrWn7XXPCrlbL9XrsMl3AKVsVzEx5eV3UNwJffzH1BwheVi9eu5uf+hEVLafVS52uk4oOoBS5aYExeajyfEWJPAFhFawM8/+Ektj6AqYAaLp466+8lPkM+2RcrMb13wmWEtvLC/FEBDn9zPW2s216JeahihiRiBysZhUx2yfGOw9n52E9p4f3sJOq12K6i8IYzV2luQ4FXgNVOmG+j8f5Wm6rbukGPTO3c1mnDBCeFqp5YUHEthrq57Hz8vjmq4KZjdfFc/Mjrp47Xj4E8lKFJKI8B8R044jrjgwS5aXu37s81w46lqO2dSs242GlVe9E02VdHQRhCp9ORzFFrw3LGC3TjORU9BSBXy3O7QqnnUsseiXmqYrY43FWEXMRKrYcyk5I9DoMtrpWOp6szhyveqpOvbUmzT5zO72d2LpdrMNrOxO3VTfA25xRt3NZf3R55vPi6huBRz9yX8X1cuwOeFjl1+tCLH62oPHyuqiula4XWMq0T+YrS7W89FAlIo/hMN3qoesM1bqxrhXu/154PjXsUoIa67mGsJlsKZLDo7C7wzZBTjpsM7GjpP3OiFQrnFJ7eVE+tiSS036Elr0SGzQc/X4gp3c9rCF89DCriG5Uepz3l6palymvw2C37nfer0uHZ/4nor4RjgugWNnjcYGfXi6DRJWH4Lt4k+666jak0tuc0d0ujseUAcJT+4WXlkTSChRejp2XVX57dSmcFjReXhdvrXAXECdWCXx7YiCj+/rTeVzwhqjoAmJaoS8dho1Jge4VOOq2HOE5JHavwKHWG7MJaLZ5zG3dREQva5yXKB3mIkqZ4dHmnMR2RwEaDmi5v13jB8Q6cEoe+iL2fJwrmrrlpXpS34isfao/rLe3B2/DXt0x4HgJH5lUBbM1d9PP4JZOkPU6HNjNYis3X+BtYvUHm/SCPHZmlaWZH8s6HycUTKzyFsrdHO87hisZ9eKsb0yvyk1EBSbzloYu8k00O/XqiD1lAWxxcy3PpYseFTgIJXqim3iyaaz4SXch11U+E6k3JBTTxhj6yEEk95VjVQVaommThh0zcnv7NY2oO1qjVfLBdxmoPVRPstns/iyPDbydTljvG+stfDgFUC+hyCuvwS2dIOt1OPDREzJlaBt7WuaP0/YD0nVVFMhvG4p8VTDNbhjprbrudLwnVgncN1HNaH5pfSNw/8vhtB5PIiqwgOj6gum8H4qEf/p2wm631/QcEntWoBqq1RBN03zDhFVJjfdVpMiCIjFwxrchkBgChbTormE1rDTVwWWgbHfUfNykAg0aEAb+z6Ty4wA65PL2e/9Or0SYVUQ3JnpsiO7nCarRlAHCU1UnVUDwWqVMp0KVS93Kc7cIkdfhwKnmsn5jmOLpOfDpjvQeo3y1ochnBdPP18W2A8nHe+Z4FZ3KgAmnZ75a6vYDErf9JezrvEsiKsIk6RRxYlXKvp3kLrdZx3NIPKmz2NcyHNRu54XLNz6RSbQ2VQyNrTZEusNHOdS0XRJAXRgNlUGU5eome3RUsKc2+pT7/ZW5DYhL9uJw09FwNwbE3JwY7zuSnRO3a8/29unGgvXOw6xPPcnb/c7WPEwnboYVem2lUHPC/WW9roqb6hie2dfbizjdNgn5akORy+pvKl5eFyP6K5CPlPj6nH9hQSRlH1Iiakvh0CEFpspbUuKUrtjp9lY9nyb2VeVuxaovovWqNYbfCfeBzFg1lLL1uvGfC2mzgioM18k4pVJbpwj8dFFu22D8+CIcRLNEzS9K6nN9dy/8Q6QbeE6RsxPj3VkKiVd4DImzVzrPR/QyxBbIbB6m1zYHbipGuWyl0NFD9cvNXNZRA7z9CU931d18taHwOmzXrxY0frwu/PLKUg1DH25iQCRq64SbnOLQJ77l9xLQgYFdxfachUQBoKqjEg1q5t8IkSI8pgrOMr0c11JFlDb7YQybzIbU+vg/tTTSJZc3ed1pKOvaL4QupajI5e1OfRNHcVzjMNMcnhhnY57dzPGqp+F3a3bqjkPTvM49y7QfntfKm5uKUS5bKXhZkdNNu4iBVbmt9uarDYXXYbvpVH8d739Ffk8Wth+QeGFBBOL+Jlz/twgXqCFiQHQOiMar6ALoGMDplVjn9uZ9WXN/YHfs2ndQ6QddxuYYWi3PY6gAJvwudh2r+54QMmXyAYnfVry6KN0kvthlRerjS+2EAmiHIn69HFzpVorSw/fkNqlJCf2lZeHO0MCQmMPgsj0LPRK9NPIGgOdT9GnzOsQ208V6vPajdDMPMpetFLysilvX6HxbXufKAulXewupDUU6Nvj0GvT6usjEK0s1HGuQrBgStWUpW70L6wDZUkwTDhmq9fd9q4IIAc05C4kXD1JePHWjfvPHCvpF+60ZSpvS8K9IcSTspgMKYbqKUx9Di41YLV7DVohkluO/v6pAINd3sfvjusKWF7kPLodP+Ptm47XB/Zqdetr9C3PFa6sRNys7ermNdBch8vI4pZrLmo/A4qUNhZcFnPJVwcxHGASiow/uXchQSNQuuSlipawwWoUqieFV2JDOrvhyojqoG7ZBwQRo0voEVAiH2CwsQqGboyJM25DWwVBwLCm5oABSQgrRNgcfrz+MmprqcFc+0LkNLoC/C7gMqfReRfz1P7LfaDuTcDSk0tvwSbd9GbMZ3Iy8VvqyNZfVi6ocHTuzYq1gms1dpWHyHDa6JyIfAqJ0CogWWVEHzugp11aGhOug6EtNYUh3bLLekkWvRKv5gcZ1ZswBMWGOYaoukxZhMWWyJoo+LY424URbvXvDn4l05WI1uT8xdrP4SDr+cH3QU8iZu0pzVW3zo/o5JM0unN8e5S38vrdW832fvAS3fLWLSEc6QdZrG4pjHpYGy2X1N5sG9+IwDiKyiS/CKurYzTe0+pm0Hn4a/1lEYkQfrE1nt3x5x+qtYm9VB9WwNYvehPFwKHWbyzjF6RRhsCX8xecbCvdXJQIAReCO9xFui3ftjOcQQR0Xq8k06Hg5MT7gYxVj1mQVFw7N/EGsrpX47lvuqhh+VD/TbVtw6XBv9+3h5brv++RFvtpFpCOdIJvPNhSFsqKo17mNA6uEL3NJiagNhsOk8JdGQLTNT7K1HWCFivP6iWU5D4kAMLyX2Ja8tXhgy2R1U5l8FZnm9YVIDpJc1ZRsXlNzVoc7t7W71aihad3OcAA6H+JMeF3N0K8qxqzJKm6d4G12wF1zwq6rmpvrMl+htCX0pRFoJ1YJjOif+Z+jt1a4K5PnspVCtttF+LEYy8h+7o/Hdzw+//xqQ5EuL/MozfyY23jfRBVERPbBL9WoSZukKCyKZPHvNWBAn5DeB9id85A4boAye3gV1iIgrMNXBvfV8veWi9+Y5h9K6X7DrCiS8ZVQ0/bGY1Y+opcgzMVqMuV1yOBxH5p4v3xNwHNAfGFBxNUwUyO3c/xsj11v9086LyfO1bUSj37k7rXrtZVCOn0Fva6KmyqQ7K73/tyacLq74+61ip3usTPyOkR4YJXwvA2j7R6D4qSzVcwcz6BI1M6TYPKPW35t7OwgMg8vxjykA+edjGUdStJbuMa3U8eze2MlVBFrS+F0h5zWeRXJvxNOv5cW3wr7bVlVJ4kML6K2ZOobOKrVhhkQvZxgds/f4iNTBghsuyeEr1/g7YRy8SY9o+XzN+z19oK4cKjiamjdHcMVTDo78/v454811xVSr8EtnWG4XlbFdVPF3VznfVGWgVUCD4xWsv4hRbrHznw/vbpvrH+h7NMd3v9Q3HNFALMme9unO4Yr+PiWoOftEFEuwqFN33fbt8VUPRGF+4AIAJrERf3xcbp77tvp49Ayubmqk2rq2xG/L8YFaoT1nXD8+2G8jo6E8acJ1UMJCJYHKUPRFU7bRFTUJCIvLQt35jBTb7wOGcxk8ZH4yd+c6SHPzdLX7NRx0e8zm2rrpudgypPzFBXCiVUCj1wf9HT/0mkV4DW4pRNYvCy24nYu69b93v/e3f+VIKYMEJaPzeoZQc8fUvgZ9jL+wGVMAHe4nPOaKnSt3e3Pm+qtEwJYPSPoer+M+7ftnhCeuinoubpLRLkIiDbBL6O3b+E+IMbzlg6gg4qLB2N+urfma6+2c/tg7TsHcSa02E62rCUjTKHQPKkSrT0V7SK2RDQACuMERQXueyaavmeWJIvXXvUJ1FdVoEOx35UOj+oBaBxm6pXX/mxuFh8xnpT6UbExBqiznsl8LaaXdkj88oD0FFQnna1i1hHrRuBTBgg8MTWY8cJA9Y3A915Lr51AZQ4XIfKyKq7buawb9uqeg0JFKTBnegiXLmg9lh3LhG/hEPBe8axv9LaAVEUp8NRNQVy1SsPHW/WkRY5mTVbRt4vApLPV6L46VN7/ukHH/R73J25EfwVP3aTgKUSHhMfNXhndvxtGtj62E05XPX9oRER5PMHMahA1bF8kh9Ez+ofqThbyi3T3w7czkotOUV46b7+85J014kyEZXKjRyFbA6M0hce0jp9hWy1hT8Qypbl3IlEaFIG734c255rivht3f4gjDTXhLnxAvevlMSQ+dVMQT+VhvxdvyryCaPT3TzXcc4W3PxO3TghgWG8FS7dFq34zx6sY3lt4GmIKAPe/HE57IREv1b26Rve35XVV3D0uhyk/+pHm2wcLfn5AkWnodQroA31YgGbS2Somna3ioesy38bmOuDdVZqvIdp8/G+dwPdeovYZENPJMC4vq+mYMBgfdCoV69I+LfbzMIzpjSVl5SK61fiqpkIgYbKXm4Vl4su1xoNfS0gWDsfd6WCxPyK5ex2/tLKpczHfBV1Ce+LDpi4cZuoPL6EiX15YEPElIALAvQs1X5qRXzhUwT1XBCAfKcE9VwQ8B8TH3o3g6XXpP8l75qgZfK7aRWyui1aMc8HL7ew74u055Mc8QD89u5hNZynFeTtRQiaR7i+a1pNL2OeheN/EgMAlg/BhJnvva0jsKHDs3L7KTqh2902Y7pCwvt/SaXGbeLNIwwI1SZM/pfODwLxIdq+G2uJ+h+/wqK5CA4eZ+qSipHjeLKprJe58MZzRIjVOHnojUlD387F3I2nNQ4zz2p8unUWIupXnrtXG8wu1nBzzD9bpOTl2VvyaB+iX+QdkwvBQIvcn+sRPDpyeN+msaGo1hU4m5ai+/UIY2wOL8h4Sz+8nXr34VLEAqpK4w9IiGAIWTe9Nv2uZp2iuBApDWEzzVSvBT3qoTbp7Po6cqAnzQPjE65DBXJq7SkPVr5ozqq6l8vQ6Ha8sLYzKyYOvhjMKiID3dibpLELkdVXcmhPpPT7ZrCbGQ/nREzInx87Kw8t1z307/TbtPc1zOwyvth9w3/6FiPLxgUGKIaHGTChThUyRIojK1g3GeyZGgMlDlXmqlBn9kfC93jC2n/y4Q4eAKdPZ3DFdpr7f5utL09FtWU3VqVUGkftXRDGucKpJRJ74gMNM/eR1yGAuLN6kY+qzzZg8J7tVjev/FsHcVfk7Ga2ulZj6bHPSgiPp8BrctqfR58/rqrgb0uwpmO4CPm7d+WJrKM+0z2G6x87OS0tyU7lLZ/7kbX8J+zIcOxNzV2kY9FhzXleNJSKngJhGJknZ4cFNddHiMqUqrhqGNzuXibUFERI7A0cvPFlugCoMqdZY/pSt90043GHz3MX4dYXdAfRjvC/xhQ3sqkPR/dmNrmYKDjP10eDuhfuGMXeVhqnPNuOi34fx0o7cnKROnpOfoBivknq9n7kMbl5XxU13QR6/hz/WN0YDorEyXX0i8+0dPuH9OZqLyt0rS7W0VgSef0Bi6gu5DYrxYeXZ/mCIiDIMh74GRKvLSxfFMQlowND+gcYv9ZQLM707vp9SntdPefXSIZgH03o1rUNNpf3BkW6TnHS4fvwLmVGOpHZOEbj5reKKWre8g+MNHGbqu/7dCiskbo8FAXF/EybPieQsHJqD4mPvRnJ2f/08Ge5Y5nFOYr374+1lVdxMA8e09zRfguKanTqufiZ56PJ8DwFtxUF/nqu3/SWclWGna3ZGK/LX/y394zf/gMS4J5uzvoBQfWN0UapsDSsnIh8ComUMcZjnJl1sy6qAJlINPQUQ1nH1MPy9c2lmVUTA5z6JcRf3xMJBJwVmbNsTDrQen1jqdQq/TlVCy2TutGqpw/hfhkVyeJEvWNdUCZQUxe42amj6w6KmDtDBKmIbNHeVht02fQbz5d6FGt7ZqOPhKwNZaea9ZqeOV5drnoaWWunjIbjVN6bXDN7Lqrhe2kXEnyeZtrN4YUHE8blWXSvTXiE23WOXKpBd/Uwz/uebQV96Bi7epGP2Ms1z6NpcB5z1TBgzx6v49sSAr3OZq2sl3lqhFdR7ABGlCIgpU2AKCQHTaS2XWL4SpnCjA+gWwNRzxBwvdysrIfHcvsrrk4bqc5/ZL66M9kzUW++kEI4ZLiHIue5cEVscR1gFR7a/oDQoAI4Xz6cIZb+KlHCYaXYM6527gxoPg+aT/UI1/4DE/N+HMbFKYPqFqueecfET4dkrdU8Vq2wFtwNpVvdy1WrDLih+sEnHjy4PYER/d8/hV5Zq+Om8SMowV9cI9OyU3WPn5rk36LFmzJqsZhSG48+1Rz/SfJ/Pd+9CDfcu1DBrsooJp6ueguwLCyJYuUuyakhUTGSqBOliAwkLd6a6uM2qp5qOq4YHVw8MYJun7Ctldv4gv71LzrjhL/rTx49E0ghq5v6I0rQiqm5KkW56IhoPOFhJpNQaJeQThb+s5bBnoG/c0aQwIFIhuGO4gpH9ou+9U8Y4V1NeWaq19AJkhST7j4nV4xF/DIr9+M+arDo+57YfkFiwXsvLc21IJXDf2Oj+XXWOavvhweJNOjbsjZ7fZCO8ElGW+ZItpIuMYw6IwvpiKjB7Wuj+qQPFowUZElfulVc/tAz/8fdPIiMhdfcHLx4Q4wfAHBITErb5QLqoIjIkUirNEtpjpZoioBbqLi74AocnPt3UjQ8WERERUaFy0QZDum1zkeoyADTgnDNCNR9MwcVdPMxHBLI4SG1kb/HmtafLV0W5sAllMnVCNi520zKnMb7KKYeQUpYIYOsRHC/U3YtIRCY+19SN7S6IiIiICj0g2p9vtn4hTFeRaQREw+I4uo4pZ2G214CY1ZAIAGd2wGeXDVE3WddjbPp+SNPBkKl6KaaoIpoXxmEVkVK+KgRufBMFO9409Cs9gAg4D5GIiIio4AOicI4v5svLdAKiYYOaxMBBZfqNw8SLvpwOZ/PwnN1befMbZ2M2Qgqgu+ljmGIFH2H4nbRoIskASH4QwPItTQUZEgc8A8ijbHdBREREVKjnka1fCPsMaRUQRTwDicRtJLXUMPwXX91UA246F3/sVYrlBR8SAeCCLlh26WnqFijCIvyZUrbV/EiRIklbpu3Y5Vg5pExfFXWF98R5YyuqP9/ZxAoiERERUSGGQ2EOMKnOJ035xuriLVnHnHNE61otYYEBQ0r1W0Zglp+nw1l1ek8x96ZR4o9qh4BFqEOaB04a/rUJi3bbZ2CkIqZLaF/9Q1NPzkMkIiIiKsCAGI8ulvMK3Vw5Od4kT7uzqU6qEtPOlc/3K8OSogmJADC6M5ZfNUxZCVVJEQiFxREStscx+r1IPGbG79n2gjy8MqQsnEhW9oiuch4iERERUYGFQ8uiYRpzCS1jUWzRzni10CpMxi8TljhjSGndv5+BP/p51wK5OH6n9RDz/s95cuiC7YH/qj3UZJX0gKTzcdMwUonkgxQ/eJKrnZLPAgI9HteV/75SOdQplMdwGIS4/jV0az7CeYhEREREBRUQk8KhiwDoevvCIhsZR1fGvq4QuGMcnuxTJpb5evey1SfRbPMhecnMFfjB8/ObJkETsYqIocQX74/Y0vrCfJAlLIefugmJrCRSJjQJFEI2CwoUbsdGIiIionYYDpEqJJqCneXv3IZJ2RocjQGxGZh4fsm2l/8NX+tWhtV+3s1Aro7nkO7iw9vOkZ3+ua1k/MadzaWpQ5vl4F7DsTIEQ1YRKRtUhjMiIiIisshzKcMhUgRE4ZBvLObMxRepiV9PB0q6q/j+ODzqd0AEcjzD6dzu4vVbL8DzKEHi6NKkKqKwD4d28V3YRHpWEYmIiIiIKBcBUaS7MUNAtAqTxlVMjTQNN49W/3F+F7ksG3c358tgXHMyXr9yeGgt1FjvROEqjiNpHK7VJE7zgWeBkYiIiIiI/AiIMp2A6NAj0S4gClN/xKTWGLEdCEsMGVLW/INx4pGu5WJ1Nu5yzkPioG5i4XfH4sl+fQLRoXxSRP9rOZbGfonmZpKGRO0YJl0mfSIiIiIiIrvQ56blYdLlLIYyJkQaU9pMWMXUcGMCiX0SRSw3dVZx38XiN4PKsDBbdz0vC+oPLsWm287HLAQQrSamJB1+Jg3/MBESEREREZEPAdEiz7m7nHSIMxLW/Q5l8vfGRWriITKi48ZRwUXXnIzXs3n38xISB3QVi741GC9efXZoNVRjUIylbtt5iU4rBJkeKc5FJCIiIiKidMOhm+ohkEGPROnw8/iXDtPqmiVOO62s8cEJ8mddy7E6m4chb625T+kiFv1oovjV6QNCJ6CIFOHP1Dwy4QAL68sRERERERGlExDhJSCmyiRW1UNTZdG8imn8chGJsh4B/Pwy+cDgcrEg24dCyefjcEFXvHz3ODxW1lWxSN7S+gDaPmAsGxIRERERUQbhMJ3hpU6NGJx/abGKqd2wU5m4nZCCu8apsy+tEvNycUiUfD8mV/TF2zPOD7wMIQ3HJJPoLpIfGyIiIiIiIifSIlq4ubzlNmyGm0ppHxClTN4R49UbJS4/J7Tuu+eI32V7mGnLnkmZ/zS175gc/X/n4bk3PgmPhA5AGBtJSkPqi/3bMtpU2GdIhkQiIiIiIvIzTDqNJJUwzSk0hUQg8XdJPzMuVBP7fVhgyOBQ8+v/Lq4eXo65ubqrSiEc714dxfJfT8L9FwwP7YciHY587F+rAy8YEImIiIiIKEtSBcSkwGe8jEgREA0bilcdw0CPfiHMvArfy2VALJiQCADDKsW8n18mHzj1lFAkGqINVcSEHiGGg2ietkhERERERJQ3dvMRpXVwNF9GxLJPWCLUXcWDXxaPjumKj3N9L5RCOqRf7iVmPThR/Kxn76B96LNazDSdlYiIiIiIiIhchzsHtqMYrQKKSB0QAUAD0EnFfRcHX7xhIGZ3Kxerc300lEJ7eC7vi3/86BLlsYquAUA3VBHjB023ak4pkx8LIiIiIiIiT6FRpL5YUji0So7CPpQKJAbEUhW3jwnN/e7Z8nddy7A6H/e+4EJi9wqs/NapePGHFyvPi84qoJuPr9UBFpyLSEREREREHghTnktzuGJ84RppDJfxNn7SYhVTU67RAAQkpl4Q/PiBsfLnPcrFynwdCaUQH55u5Vh9xwjx1I8mBP6MChGtKAIuWmMQERERERFlEBCFm4AoU6REi+1atr4wLWKjSUCRuPa8kk8fuRQ/6FsuluTzaCiF+jB1KcPaH5yDR++/JDgblaaKorTpj0hERERERJRBRmzJedIc/OyGkFplP4dVTIVV8JQtBbGrRpeunnm5+F6/UizJ++GQBV6dq23E8EdW4oe/+TB8o6zVEW2RwWBIREREREQ+hkNHNkNEM7qcaZGaIPBvo0tW/m4y7jqlDIsK4rDIIhjCWdeMYb9bJe9+eL68vflQGFDNyZ6IiIiIiCiDgJgqJLa04xPOGURKh+GqhkpkPCBGAJQp+MZ5gSW/uVTcXygBsWhCIgA0hDH42fWY8YsPtbtr9kUKeKAsEREREREVfTgETKNMTVPepF0WNFQKjRcShjCpAahQMO2i4LyffUn8rG8BDDEtypAIAI0RDH5lu/z6g/PELz/f0QiorCISEREREVEGITGtGORiGKmM/U8Y06UwBU4JNAMlPYO4e5wy+95zxX/2KMXKgjtEsshWDG2KYND/O4QJD76PX36yprEnhGBVkYiIiIiI3IVDNwExaUSpy+GmQKyKaLq8iK1y2iTR/ZQS/GSC8tjNQ/HHzqVYW5CHShZpW4mNjbjs/nfw2zeXNp0FCcM8RSIiIiIiIouAKF0lQpvgaDfnEKYhpqYkKkS0xUUYGHpaaeNvrsD9F/fEgkINiEUdEgGgWcege+fjsaeX6VfLI80cfkpERERERC7DoSEgusqJLqqJVhVETQJBgYnDQ9tmXo17zu4g3iz4wyaLvEG9LtH/hY2Y9sg/8cNtWxoDHH5KRERERERpDS913eLC4bLSNB9RCKBRovSkIG47X/n7vRfgP/uXiY+L4tAVe0iMW3YM1z08Fw++szJ8Jpp1Dj8lIiIiImI4dHd5aQ6BwiEgihRfI7p6qaZj8JDS5p9cKh7+t77yjc5lYm3RHMK2EhIBIAwMeGgJ/uOZJfpNNbtjw09ZVSQiIiIiaocB0cUY0qThqE4VRcP27NpcAECzBLoouGZE8NP/uFT8bEQl3im6w9iWQmJMv/f3Y9LMRfj++582DUVEcq4iEREREVG7C4iwD4m24TD2y6TqosW2zQvVaDqgC5w6tDRy5xg8OWUIZleV4tOiPJRtMCQCABqBwY9+gvte+ATTvvi8MfpgcwgqEREREVE7CYluA6LF76VDmwtzONQl0CxRUlWCr41QPr7vYvz6rCKsHraLkBjTb1U9Rs5ciO+/tFIfFznMIahERERERG06JMoMLyNj/xPmC9oMPdUFEJFAuYoLTgvuv+si+fik3uIfXQq4tQVDoiksvvYFvvbcEkyf91nTUNRHl6ElIiIiIqI2FBIzDYgt2c9hrqExIIYBqMDQQaWN/z4af7zhDPnn/iXFsXIpQ6JJIzD49+txy//+CzcvXd90EpolK4tERERERO0hJKbFIiDqiM47hMApp5bimuHy1dvGiOeHhTCvzR3K9hQS444Bw19YjWkvr8aUpRubTkKDBAIMi0REREREbZM59LlocxHve6gLQItmpv6DSnHV6XjztvPk8wODYntlCBvaZN5ujyHRGBb/8hlufO0zfO3DzZHBOBoBFC5wQ0RERERUfMkGFpVEq1VOzT+LhULz9SMy+n2pwLBTSk5ceRre/tYo+eLAALZXlogNbfpQtueQGHcCGPqPnbj8tbW4bu5mXFSzqzH6JOFQVCIiIiKi4gyILauUmkNiPBuaFqmRsf80GQ2IPQIYNyiw89oz8NqVp4m3B4ewoN0cTobEVjrQf+0JnPHX1ZjywRZ8efn2SE/URhgYiYiIiIgKOSACzkVD2AVIEW1hoUlAE0CZilP6BzH2ZCyaOgqzz+kqPz0pJJa3u0PKkGjtCHDmP/dg/Lsb8JVF2zFuw+dN5aiX0aGoDIxERERERIUVEs2cYo6OWDAEEJTo2bsEY05RVn55KOZOPBXzT1bwRXkQm9rtIWVITG0/MPrjnbjow624dNkujFnxRaQrDkeiQZFVRiIiIiKi/AfE+Fo00iEUSkSDYScVp5wUxOiTsWz8KVh48UDM7xfC7o5BrONBZUhM22HgrG3HMPiDTbhk5V6MWrMfZ23e0xRCbew4KohWGwWDIxERERFR1gOitAiEMlYl1GO/Lxeo6hnEGb2ULWf2wdpLT8W8od2xqY+C3WUBbOHBZEj01T5g9OdHMWDpLozZcADDtlRjyJYaDNhTEwYOhwGpRJ/AiuHJrMS+iD+xGSaJiIiIiJzphlAoZPR73RgMAeg60CmIzl2DGNQVh07tgS1DumPT+f2w7NRu2NIziOouKtbyYDIk5tQxYPgRHZ2PNqDzumqc+XkN+u89ht57a9HnwHGcVH0CVYfq9UBtgw55QgOaAUQ0IGx4khMRERERUWsxJahEp3iVKkAIqCxT0bVCQc9yHOrZAQeqOmB/7w7Y07czdg/vKdd1rxAHOwdxtJeK5TyIDIkFbw9w/okwypvCKG2IoKxZRyiiIRCRCEidNUUiIiIiIqC1e4UAEFARUVVEQgE0h1Q0lwbQUKaisUJBXQ+BlTxaDIlERERERESUJaxcEREREREREUMiERERERERMSQSERERERERQyIRERERERExJBIRERERERFDIhERERERETEkEhEREREREUMiERERERERMSQSERERERERQyIRERERERExJBIRERERERFDIhERERERETEkEhEREREREUMiERERERERMSQSERERERERQyIRERERERExJBIRERERERFDIhERERERETEkEhEREREREUMiERERERERMSQSERERERERQyIRERERERExJBIRERERERFDIhERERERETEkEhEREREREUMiERERERERMSQSERERERERQyIRERERERExJBIRERERERExJBIRERERERFDIhERERERETEkEhEREREREUMiERERERERMSQSERERERERQyIRERERERExJBIRERERERFDIhEREREREfno/w8AajOJ0LdM+t4AAAAASUVORK5CYII="


sg.theme("Reddit")
themes = {"Light": "Reddit", "Dark1": "Dark", "Dark2": "DarkGrey11", "Dark3": "Black"}
# themes = {theme:theme for theme in sg.theme_list()}
button_color = sg.theme_button_color()  # get button color from reddit theme
if sg.running_windows():
    font = ("Segoe UI", 12)
else:
    font = ("Arial", 14)
sg.SetOptions(font=font, icon=icon, element_padding=(5, 5))
screen_size = sg.Window.get_screen_size()
image_aspect_ratio = 0.5


# results queue for threads
results_queue = queue.Queue()
cancel_flag = threading.Event()

weekday_list = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
analysis_options = {
    "weekday_exclusions": [],
    "put_or_call": True,
    "idv_weekday": True,
    "news_exclusions": [],
}

news_events = {
    "CPI": [],
    "Initial Jobless Claims": [],
    "Retail Sales": [],
    "ADP": [],
    "JOLT": [],
    "Unemployment/NFP": [],
    "PPI": [],
    "GDP": [],
    "PCE": [],
    "Triple Witching": [],
    "Beige Book": [],
    "ISM Manufacturing PMI": [],
    "ISM Services PMI": [],
    "S&P Global PMI": [],
    "Fed Chair Speech": [],
    "FOMC Minutes": [],
    "FOMC": [],
    "MI Consumer Sent.": [],
    "Chicago PMI": [],
}
news_events_loaded = False


# Allows custom checkbox icon
class Checkbox(sg.Checkbox):
    elements = []

    def __init__(self, *args, **kwargs):
        font = kwargs.get("font", sg.DEFAULT_FONT)
        w, h = sg.Text.char_width_in_pixels(font), sg.Text.char_height_in_pixels(font)
        text_color = kwargs.get("text_color", sg.theme_text_color())
        background_color = kwargs.get("background_color", sg.theme_background_color())
        self.images = [self.icon(i, h, text_color, background_color) for i in range(2)]
        size = kwargs.get("size", None)
        size = (size, 1) if isinstance(size, int) else size
        size = (
            (size[0] * w + h + h // 3, size[1] * h)
            if size
            else (len(args[0]) * w + h + h // 3, h)
        )
        kwargs["size"] = size
        super().__init__(*args, **kwargs)
        Checkbox.elements.append(self)

    @staticmethod
    def initial(window):
        # Called after window finalized
        for element in Checkbox.elements:
            element.widget.configure(
                indicatoron=False,
                image=element.images[0],
                selectimage=element.images[1],
                compound=sg.tk.LEFT,
                borderwidth=0,
                offrelief=sg.tk.FLAT,
                selectcolor=sg.theme_background_color(),
            )
        window.refresh()

    def icon(self, i, h, fg, bg):
        box = (h, h)
        im = Image.new("RGBA", (h + h // 3, h), bg)
        im_check = Image.open(BytesIO(base64.b64decode(checked if i else unchecked)))
        im_check = im_check.resize(box, resample=Image.LANCZOS)
        im.paste(im_check, (0, 0), im_check)
        photo_image = ImageTk.PhotoImage(im)
        return photo_image

    @staticmethod
    def clear_elements():
        Checkbox.elements.clear()


def with_gc(func):
    """
    Decorator to garbage collect threaded functions.
    This resolves the Tcl_AsyncDelete error
    """

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        result = func(*args, **kwargs)
        gc.collect()
        return result

    return wrapper


def analyze(
    df: pd.DataFrame,
    settings: dict,
) -> Tuple[
    pd.DataFrame, pd.DataFrame, pd.DataFrame, pd.DataFrame, pd.DataFrame, pd.DataFrame
]:
    if df.empty or settings["-PASSTHROUGH_MODE-"]:
        return pd.DataFrame(columns=["Date Range"]), pd.DataFrame(
            columns=["Date Range"]
        )
    short_avg_period = settings["-AVG_PERIOD_1-"]
    long_avg_period = settings["-AVG_PERIOD_2-"]
    short_weight = settings["-PERIOD_1_WEIGHT-"] / 100
    long_weight = settings["-PERIOD_2_WEIGHT-"] / 100
    calc_type = settings["-CALC_TYPE-"]
    agg_type = "".join(word[0] for word in settings["-AGG_TYPE-"].split("-"))

    def calculate_avg_pnl(df: pd.DataFrame) -> float:
        if df.columns[0] == "Date Opened":  # OO BT data
            return df["P/L"].sum() / df["No. of Contracts"].sum()
        elif df.columns[0] == "TradeID":  # BYOB BT data
            df["P/L"] = (
                df["ProfitLossAfterSlippage"] - df["CommissionFees"] / 100
            ) * 100
            return df["P/L"].mean()
        else:
            raise ValueError("Unknown dataset type")

    def calculate_pcr(df: pd.DataFrame) -> float:
        if df.columns[0] == "Date Opened":  # OO BT data
            return df["P/L"].sum() / (df["Premium"] * df["No. of Contracts"]).sum()
        elif df.columns[0] == "TradeID":  # BYOB BT data
            df["P/L"] = df["ProfitLossAfterSlippage"] - df["CommissionFees"] / 100
            return df["P/L"].sum() / df["Premium"].sum()
        else:
            raise ValueError("Unknown dataset type")

    def calculate_rolling_averages(df, short_avg_period, long_avg_period, agg_type):
        if agg_type == "W":
            short_avg_period = int(short_avg_period * 4.33)
            long_avg_period = int(long_avg_period * 4.33)
        elif agg_type == "SM":  # semi-monthly
            short_avg_period = int(short_avg_period * 2)
            long_avg_period = int(long_avg_period * 2)

        short_avg = df.rolling(short_avg_period, min_periods=1).mean()
        long_avg = df.rolling(long_avg_period, min_periods=1).mean()
        weighted_avg = short_weight * short_avg + long_weight * long_avg
        return weighted_avg

    def create_output_labels(df, long_avg_period, start_date, end_date, agg_type):
        output_labels = pd.DataFrame(index=df.index)
        for i, (date, row) in enumerate(df.iterrows()):
            if agg_type == "M":
                current_period_end = date.to_timestamp() + pd.offsets.MonthEnd(1)
                previous_period_start = (
                    current_period_end - pd.DateOffset(months=long_avg_period - 1)
                ).replace(day=1)
            elif agg_type == "W":
                current_period_end = date.to_timestamp() + pd.offsets.Week(weekday=6)
                previous_period_start = current_period_end - pd.DateOffset(
                    weeks=int(long_avg_period * 4.33)
                )
            elif agg_type == "SM":  # Semi-Monthly
                if date.day <= 15:
                    current_period_end = pd.Timestamp(date.year, date.month, 15)
                    previous_period_start = current_period_end - pd.DateOffset(
                        months=long_avg_period
                    )
                else:
                    current_period_end = pd.Timestamp(
                        date.year, date.month, date.days_in_month
                    )
                    previous_period_start = (
                        current_period_end - pd.DateOffset(months=long_avg_period - 1)
                    ).replace(day=1)
                # if previous_period_start.day > 15:
                #     previous_period_start = previous_period_start.replace(day=16)
                # else:
                #     previous_period_start = previous_period_start.replace(day=1)
            else:
                current_period_end = date.to_timestamp() + pd.offsets.DateOffset(
                    freq=agg_type
                )
                previous_period_start = current_period_end - pd.DateOffset(
                    freq=agg_type, periods=long_avg_period - 1
                )

            if i == 0:
                date_range_label = f"{end_date} - {previous_period_start.date()}"
            elif i == len(df) - 1:
                date_range_label = f"{current_period_end.date()} - {start_date}"
            else:
                date_range_label = (
                    f"{current_period_end.date()} - {previous_period_start.date()}"
                )
            output_labels.loc[date, "Date Range"] = date_range_label
        return output_labels

    def perform_analysis(df_grouped):
        if calc_type == "PCR":
            df_calc = df_grouped.apply(calculate_pcr, include_groups=False)
        elif calc_type == "PnL":
            df_calc = df_grouped.apply(calculate_avg_pnl, include_groups=False)
        else:
            raise ValueError("Invalid calc_type. Expected 'PCR' or 'PnL'.")

        if isinstance(df_calc.index, pd.MultiIndex):
            df_calc = df_calc.unstack(level=-1)

        weighted_avg = calculate_rolling_averages(
            df_calc, short_avg_period, long_avg_period, agg_type
        )
        one_month_avg = df_calc.rolling(
            1 if agg_type == "M" else 2 if agg_type == "SM" else 4, min_periods=1
        ).mean()

        weighted_avg.sort_index(ascending=False, inplace=True)
        one_month_avg.sort_index(ascending=False, inplace=True)

        if isinstance(weighted_avg, pd.Series):
            weighted_avg = weighted_avg.to_frame()

        if calc_type == "PCR":
            weighted_avg = weighted_avg.apply(lambda x: round(x, 4))
            one_month_avg = one_month_avg.apply(lambda x: round(x, 4))
        elif calc_type == "PnL":
            weighted_avg = weighted_avg.apply(lambda x: round(x, 2))
            one_month_avg = one_month_avg.apply(lambda x: round(x, 2))

        output_labels = create_output_labels(
            weighted_avg, long_avg_period, start_date, end_date, agg_type
        )
        one_month_avg_labels = create_output_labels(
            one_month_avg, 1, start_date, end_date, agg_type
        )

        df_output = pd.concat([output_labels, weighted_avg], axis=1)
        df_output_1mo_avg = pd.concat([one_month_avg_labels, one_month_avg], axis=1)

        return df_output, df_output_1mo_avg

    # get list of news event dates to skip.
    news_date_exclusions = []
    if settings["-APPLY_EXCLUSIONS-"] != "Walk Forward Test":
        for release, date_list in news_events.items():
            if release in settings["-NEWS_EXCLUSIONS-"]:
                news_date_exclusions += date_list

        # filter df for news exclusions
        df = df[~df["EntryTime"].dt.date.isin(news_date_exclusions)]

        # filter for weekday exlusions
        df = df[~df["Day of Week"].isin(settings["-WEEKDAY_EXCLUSIONS-"])]

    if agg_type == "SM":
        # Custom function to create semi-monthly periods
        def semi_monthly_period(date):
            return pd.Timestamp(
                date.year, date.month, 15 if date.day <= 15 else date.days_in_month
            )

        df["period"] = df["EntryTime"].apply(semi_monthly_period)
        df_grouped_combined = df.groupby(["period", "Time"])
    else:
        df_grouped_combined = df.groupby(
            [df["EntryTime"].dt.to_period(agg_type), "Time"]
        )
    start_date = df["EntryTime"].min().date()
    end_date = df["EntryTime"].max().date()

    if df.empty:
        df_output_combined, df_output_1mo_avg_combined = pd.DataFrame(
            columns=["Date Range"]
        ), pd.DataFrame(columns=["Date Range"])
    else:
        df_output_combined, df_output_1mo_avg_combined = perform_analysis(
            df_grouped_combined
        )

    return (
        df_output_combined,
        df_output_1mo_avg_combined,
    )


def create_excel_file(
    file,
    settings,
    open_files,
) -> dict:
    calc_type = settings["-CALC_TYPE-"]
    short_avg_period = settings["-AVG_PERIOD_1-"]
    short_weight = settings["-PERIOD_1_WEIGHT-"] / 100
    long_avg_period = settings["-AVG_PERIOD_2-"]
    long_weight = settings["-PERIOD_2_WEIGHT-"] / 100
    top_x = settings["-TOP_X-"]
    weekday_exclusions = []
    news_date_exclusions = []
    if settings["-APPLY_EXCLUSIONS-"] != "Walk Forward Test":
        weekday_exclusions = settings["-WEEKDAY_EXCLUSIONS-"]
        # get list of news event dates to skip.
        for release, date_list in news_events.items():
            if release in settings["-NEWS_EXCLUSIONS-"]:
                news_date_exclusions += date_list

    # load the data
    result = load_data(file)
    if result:
        df, start_date, end_date = result
        filtered_df = df[
            (~df["Day of Week"].isin(weekday_exclusions))
            & (~df["EntryTime"].dt.date.isin(news_date_exclusions))
        ]
    else:
        return

    # path and orginal filename
    path = os.path.join(os.path.dirname(file), "data", "heatmaps")
    org_filename = os.path.splitext(os.path.basename(file))[0]
    os.makedirs(path, exist_ok=True)

    # Create filename
    filename = os.path.join(
        path,
        (
            f"{org_filename}-TWAvg({calc_type})_{short_avg_period}mo({short_weight * 100:.0f})-{long_avg_period}mo({long_weight * 100:.0f})_{start_date} -"
            f" {end_date}.xlsx"
        ),
    )

    # Create a Pandas Excel writer using XlsxWriter as the engine
    with pd.ExcelWriter(filename, engine="xlsxwriter") as writer:

        # Get the xlsxwriter workbook
        workbook = writer.book

        # get the sheets for day of week
        day_to_num = {
            "Monday": 1,
            "Tuesday": 2,
            "Wednesday": 3,
            "Thursday": 4,
            "Friday": 5,
            "Saturday": 6,
            "Sunday": 7,
        }

        days_sorted = ["All"]
        if settings["-IDV_WEEKDAY-"]:
            # This gets the unique days of the week from the DataFrame, then sorts them based on the numerical value
            days_sorted = days_sorted + sorted(
                [
                    d
                    for d in filtered_df["Day of Week"].unique()
                    if d not in settings["-WEEKDAY_EXCLUSIONS-"]
                ],
                key=lambda day: day_to_num[day],
            )

        df_dicts = {"Put-Call Comb": {}}
        if settings["-PUT_OR_CALL-"]:
            df_dicts["Puts"] = {}
            df_dicts["Calls"] = {}

        if settings["-GAP_ANALYSIS-"]:
            for strat in df_dicts.copy():
                df_dicts[f"{strat} Gap Up"] = {}
                df_dicts[f"{strat} Gap Down"] = {}

        gap_error = False
        for strat in df_dicts.copy():
            for day in days_sorted:
                # check for cancel flag to stop thread
                if cancel_flag.is_set():
                    return

                # filter for the weekday
                # we will keep a dataset with exlusions filtered out and one
                # with all the data.  We will sort and filter those both for
                # the analysis but the analysis will only happen on the filtered df
                # this will allow us to store either the filtered df that has the
                # exclusions removed or the original df that was filtered for the analysis
                # type, but still has the excluded events.  This filtered, but non-excluded
                # df will be what is used for the WF test.  This allows events/weekday exclusions
                # to be done for analysis only, but still traded during the WF test.
                if day == "All":
                    _df = df
                    _filtered_df = filtered_df
                else:
                    _df = df[df["Day of Week"] == day]
                    _filtered_df = filtered_df[filtered_df["Day of Week"] == day]

                # filter for calls/puts
                if strat.startswith("Puts"):
                    _df = _df[_df["OptionType"] == "P"]
                    _filtered_df = _filtered_df[_filtered_df["OptionType"] == "P"]
                elif strat.startswith("Calls"):
                    _df = _df[_df["OptionType"] == "C"]
                    _filtered_df = _filtered_df[_filtered_df["OptionType"] == "C"]

                # filter for gaps
                _gap_type = "Gap%" if settings["-GAP_TYPE-"] == "%" else "Gap"
                try:
                    if strat.endswith("Gap Up"):
                        _df = _df[_df[_gap_type] > settings["-GAP_THRESHOLD-"]]
                        _filtered_df = _filtered_df[
                            _filtered_df[_gap_type] > settings["-GAP_THRESHOLD-"]
                        ]
                    elif strat.endswith("Gap Down"):
                        _df = _df[_df[_gap_type] < -settings["-GAP_THRESHOLD-"]]
                        _filtered_df = _filtered_df[
                            _filtered_df[_gap_type] < -settings["-GAP_THRESHOLD-"]
                        ]
                except KeyError:
                    # gap data did not load, maybe no internet
                    _df = pd.DataFrame(columns=df.columns)
                    _filtered_df = pd.DataFrame(columns=df.columns)
                    if not gap_error:
                        gap_error = True  # only notify once
                        results_queue.put(
                            (
                                "-ERROR-",
                                "Gap data could not be loaded!\nAnalysis will continue without it.",
                            )
                        )

                # run the analysis
                if settings["-APPLY_EXCLUSIONS-"] != "Walk Forward Test":
                    # exclusions are only for WF, so use the non-filtered df
                    df_output, df_output_1mo_avg = analyze(_df, settings)
                    # store the results and the original df in case we need it later
                    df_dicts[strat][day[:3]] = {"org_df": _df, "result_df": df_output}
                else:
                    # otherwise we use the filtered/excluded df for analysis
                    df_output, df_output_1mo_avg = analyze(_filtered_df, settings)
                    # store the results and the original df in case we need it later
                    if settings["-APPLY_EXCLUSIONS-"] == "Analysis":
                        # since we are only excluded from analysis we will store the non-filtered df
                        df_dicts[strat][day[:3]] = {
                            "org_df": _df,
                            "result_df": df_output,
                        }
                    else:
                        # otherwise we are exluding from both so we can should store the filtered df
                        df_dicts[strat][day[:3]] = {
                            "org_df": _filtered_df,
                            "result_df": df_output,
                        }

                # create the sheets
                if not settings["-PASSTHROUGH_MODE-"]:
                    df_output.to_excel(
                        writer, sheet_name=f"{strat}_{day[:3]}", index=False
                    )
                    df_output_1mo_avg.to_excel(
                        writer, sheet_name=f"{strat}_1mo-{day[:3]}", index=False
                    )

        # use All df from Put/Call Combined for row and col lengths
        df_output = df_dicts["Put-Call Comb"]["All"]["result_df"]
        # Set the PCR columns to percentage format
        percent_format = workbook.add_format({"num_format": "0.00%", "align": "center"})
        top_x_format = workbook.add_format(
            {"bold": 1, "font_color": "#FFFFFF"}
        )  # white
        for row in range(
            2, len(df_output) + 2
        ):  # +2 because Excel's index starts from 1 and there is a header row
            for worksheet in writer.sheets.values():
                # Apply a conditional format to the PCR cells in the current row
                worksheet.conditional_format(
                    f"B{row}:{get_column_letter(len(df_output.columns))}{row}",
                    {
                        "type": "3_color_scale",
                        "min_color": "red",
                        "mid_color": "yellow",
                        "max_color": "green",
                    },
                )
                # Format top x values in bold white text
                if top_x > 0:
                    worksheet.conditional_format(
                        f"B{row}:{get_column_letter(len(df_output.columns))}{row}",
                        {
                            "type": "top",
                            "value": top_x,
                            "format": top_x_format,
                        },
                    )
                if calc_type == "PCR":
                    worksheet.set_row(row - 1, None, percent_format)

        # Adjust the column widths
        for column in df_output:
            column_length = max(
                df_output[column].astype(str).map(len).max() + 1, len(column) + 1
            )
            col_idx = df_output.columns.get_loc(column)
            for worksheet in writer.sheets.values():
                worksheet.set_column(col_idx, col_idx, column_length)

    # open file in excel
    if open_files:
        try:
            if platform.system() == "Windows":
                os.startfile(filename)
            elif platform.system() == "Darwin":  # This is the value returned for macOS
                subprocess.Popen(["open", filename])
            else:
                subprocess.call(("xdg-open", filename))  # linux
        except:
            pass

    return df_dicts


def chunk_list(input_list, chunk_size=4):
    return [
        input_list[i : i + chunk_size] for i in range(0, len(input_list), chunk_size)
    ]


def export_oo_sig_file(trade_log_df: pd.DataFrame, filename: str):
    """
    Takes a trade log df and converts to an
    Option Omega signal file that can be loaded
    into OO for backtesting and adding to OO portfolio
    """
    signal_data = []
    for _, trade in trade_log_df.iterrows():
        if "Legs" in trade and isinstance(trade["Legs"], str):
            # OO data processing (unchanged)
            legs = trade["Legs"].split("|")
            for leg in legs:
                leg_parts = leg.strip().split(" ")
                signal_data.append(
                    {
                        "OPEN_DATETIME": (
                            trade["Date Opened"].strftime("%Y-%m-%d")
                            + " "
                            + trade["Time Opened"][:5]
                        ),
                        "BUY_SELL": "B" if leg_parts[5] == "BTO" else "S",
                        "CALL_PUT": leg_parts[4],
                        "STRIKE": leg_parts[3],
                        "EXPIRATION": trade["Date Opened"].strftime("%Y-%m-%d"),
                        "QUANTITY": int(leg_parts[0]) * trade["qty"],
                    }
                )
        else:
            # BYOB data processing
            open_datetime = trade["EntryTime"].strftime("%Y-%m-%d %H:%M")

            # Handle close datetime
            if pd.notnull(trade["CloseDate"]) and pd.notnull(trade["CloseTime"]):
                close_datetime = f"{trade['CloseDate']} {trade['CloseTime'][:5]}"
            else:
                # Use OpenDate and set time to 16:00 if CloseDate or CloseTime is missing
                close_datetime = f"{trade['OpenDate']} 16:00"

            signal_data.append(
                {
                    "OPEN_DATETIME": open_datetime,
                    "BUY_SELL": "S",  # We'll do short for the first leg
                    "CALL_PUT": trade["OptionType"],
                    "STRIKE": trade["ShortStrike"],
                    "EXPIRATION": trade["OpenDate"],
                    "QUANTITY": trade["qty"],
                }
            )
            signal_data.append(
                {
                    "OPEN_DATETIME": open_datetime,
                    "BUY_SELL": "B",  # We'll do long for the second leg
                    "CALL_PUT": trade["OptionType"],
                    "STRIKE": trade["LongStrike"],
                    "EXPIRATION": trade["OpenDate"],
                    "QUANTITY": trade["qty"],
                }
            )

    path = os.path.dirname(filename)
    basename = os.path.basename(filename)
    result_df = pd.DataFrame(signal_data)
    result_df.to_csv(filename, index=False)  # full signal file with puts and calls
    for right in ["Puts", "Calls"]:  # separate signal files
        fitlered = result_df[result_df["CALL_PUT"] == right[0]]
        file_path = os.path.join(path, f"{right}_{basename}")
        fitlered.to_csv(file_path, index=False)

    return result_df


def get_dpi_scale():
    try:
        user32 = ctypes.windll.user32
        user32.SetProcessDPIAware()
        dpi = user32.GetDpiForSystem()
        return dpi / 96.0  # 96 is the standard DPI
    except:
        return 1  # Default to no scaling if not on Windows or if there's an error


def format_float(value):
    """This will remove decmal from float for GUI
    display purposes, but only when decimal is .0"""
    if isinstance(value, float) and value.is_integer():
        return str(int(value))
    elif value == float("-inf"):
        return ""
    elif isinstance(value, bool):
        return value
    else:
        return str(value)


@with_gc
def get_correlation_matrix(results):
    # Create a DataFrame with daily PnL for each strategy
    pnl_data = {strategy: df["Day PnL"] for strategy, df in results.items()}
    pnl_df = pd.DataFrame(pnl_data)

    # Calculate the correlation matrix
    corr_matrix = pnl_df.corr()

    # Create a heatmap
    plt.figure(figsize=(8, 5))
    sns.heatmap(corr_matrix, annot=True, cmap="coolwarm", vmin=-1, vmax=1, center=0)
    plt.title("Strategy Correlation Matrix")

    # Rotate x-axis labels
    plt.xticks(rotation=30, ha="right")

    # Rotate y-axis labels
    plt.yticks(rotation=0, ha="right")

    # Adjust layout to prevent cutting off labels
    plt.tight_layout()

    # Save the plot to a buffer
    buf = BytesIO()
    plt.savefig(buf, format="png", dpi=150, bbox_inches="tight")
    buf.seek(0)

    # Convert the image to base64
    img_str = base64.b64encode(buf.getvalue())
    plt.close()

    return img_str


@with_gc
def get_monthly_pnl_chart(results):
    plt.figure(figsize=(12, 6))

    # Get all unique months across all strategies
    all_months = set()
    for df in results.values():
        df["Date"] = pd.to_datetime(df["Date"])
        all_months.update(df["Date"].dt.to_period("M"))
    all_months = sorted(list(all_months))

    # Set up the x-axis
    x = np.arange(len(all_months))
    width = 0.8 / len(results)  # Adjust bar width based on number of strategies

    # Plot bars for each strategy
    for i, (strategy, df) in enumerate(results.items()):
        monthly_pnl = df.groupby(df["Date"].dt.to_period("M"))["Day PnL"].sum()

        # Align the strategy's data with all_months
        pnl_values = [monthly_pnl.get(month, 0) for month in all_months]

        plt.bar(x + i * width, pnl_values, width, label=strategy, alpha=0.8)

    plt.title("Monthly PnL")
    plt.xlabel("Month")
    plt.ylabel("PnL")
    plt.legend()

    # Set x-axis ticks
    plt.xticks(
        x + width * (len(results) - 1) / 2,
        [m.strftime("%Y-%m") for m in all_months],
        rotation=45,
        ha="right",
    )

    plt.tight_layout()
    # buffer for saving data
    buf = BytesIO()
    plt.savefig(buf, dpi=150, bbox_inches="tight")
    buf.seek(0)
    # Convert PNG to base64 string
    img_str = base64.b64encode(buf.getvalue())
    plt.close()
    return img_str


@with_gc
def get_pnl_plot(results):
    table_data = []
    plt.figure(figsize=(8, 4))
    for strategy, df in results.items():
        plt.plot(df["Date"], df["Current Value"], label=strategy)
        # Calculate summary statistics for the strategy
        final_value = df["Current Value"].iloc[-1]
        max_dd = df["Max DD"].max()
        dd_days = df["DD Days"].max()
        initial_value = df["Initial Value"].min()
        total_return = (final_value - initial_value) / initial_value
        win_streak = df["Win Streak"].max()
        loss_streak = df["Loss Streak"].max()
        # CAGR
        start_dt = df["Date"].iloc[0]
        end_dt = df["Date"].iloc[-1]
        years = (end_dt - start_dt).days / 365.25
        cagr = ((final_value / initial_value) ** (1 / years)) - 1

        # Sharpe Ratio
        df["Daily Return"] = df["Current Value"].pct_change()
        std_dev = df["Daily Return"].std()
        risk_free_rate = 0.02 / 252  # Assume 2% annual risk-free rate, convert to daily
        excess_returns = df["Daily Return"] - risk_free_rate
        sharpe_ratio = np.sqrt(252) * excess_returns.mean() / std_dev  # Annualized

        if max_dd:
            mar = cagr / max_dd
        else:
            mar = float("inf")

        # Group PnL by month
        df["YearMonth"] = df["Date"].dt.to_period("M")
        monthly_pnl = df.groupby("YearMonth")["Day PnL"].sum()

        # Calculate largest and lowest monthly PnL with their corresponding dates
        largest_monthly_pnl = monthly_pnl.max()
        largest_monthly_pnl_date = monthly_pnl.idxmax().to_timestamp()
        lowest_monthly_pnl = monthly_pnl.min()
        lowest_monthly_pnl_date = monthly_pnl.idxmin().to_timestamp()

        # Format the date strings
        largest_monthly_pnl_str = (
            f"{largest_monthly_pnl:,.2f} {largest_monthly_pnl_date.strftime('%b%y')}"
        )
        lowest_monthly_pnl_str = (
            f"{lowest_monthly_pnl:,.2f} {lowest_monthly_pnl_date.strftime('%b%y')}"
        )

        # Create row for Table
        row_data = [
            f"{strategy}",
            f"{final_value:,.2f}",
            f"{(final_value - initial_value):,.2f}",
            f"{total_return:,.2%}",
            f"{cagr:.2%}",
            f"{max_dd:.2%}",
            f"{dd_days}",
            f"{win_streak}",
            f"{loss_streak}",
            largest_monthly_pnl_str,
            lowest_monthly_pnl_str,
            f"{mar:.2f}",
            f"{sharpe_ratio:.2f}",
        ]

        table_data.append(row_data)

    plt.title("P/L Walk Forward Test")
    plt.xlabel("Date")
    plt.ylabel("Current Value")
    plt.legend()
    plt.grid(True)
    # plt.xticks(rotation=45)
    plt.tight_layout()

    # buffer for saving data
    buf = BytesIO()
    plt.savefig(buf, dpi=150)
    buf.seek(0)
    # Convert PNG to base64 string
    img_str = base64.b64encode(buf.getvalue())
    plt.close()
    return table_data, img_str


@with_gc
def get_news_event_pnl_chart(results, sum=True):
    # Get list of news events
    events = list(news_events.keys())

    # Initialize a dictionary to hold summed PnL for each strategy and news event
    summed_pnls = {
        strategy: {event: 0 for event in events} for strategy in results.keys()
    }

    # Sum the PnL values for each strategy and news event
    for strategy, df in results.items():
        for event, dates in news_events.items():
            event_dates = pd.to_datetime(dates)
            if sum:
                event_pnl = df[df["Date"].dt.date.isin(event_dates.date)][
                    "Day PnL"
                ].sum()
            else:
                event_pnl = df[df["Date"].dt.date.isin(event_dates.date)][
                    "Day PnL"
                ].mean()
            summed_pnls[strategy][event] = event_pnl

    # Prepare data for the bar chart
    x = np.arange(len(events))  # the label locations
    width = 0.8 / len(results)
    fig, ax = plt.subplots(figsize=(10, 5))

    # Plot bars for each strategy
    for i, (strategy, pnl_dict) in enumerate(summed_pnls.items()):
        pnls = [pnl_dict[event] for event in events]
        ax.bar(x + (i - (len(results) - 1) / 2) * width, pnls, width, label=strategy)

    # Add labels, title, and custom x-axis tick labels
    if sum:
        ax.set_ylabel("Total PnL")
        ax.set_title("PnL by News Event")
    else:
        ax.set_ylabel("Average PnL")
        ax.set_title("Avgerage PnL Per News Event")
    ax.set_xticks(x)
    ax.set_xticklabels(events, rotation=45, ha="right")
    ax.legend(loc="upper center", bbox_to_anchor=(0.5, 1.25), ncol=min(len(results), 4))

    fig.subplots_adjust(bottom=0.3)
    plt.tight_layout()
    # buffer for saving data
    buf = BytesIO()
    plt.savefig(buf, dpi=150, bbox_inches="tight")
    buf.seek(0)
    # Convert PNG to base64 string
    img_str = base64.b64encode(buf.getvalue())
    plt.close()
    return img_str


@with_gc
def get_weekday_pnl_chart(results):
    # Filter weekdays based on exclusions
    weekdays = [day[:3] for day in weekday_list]

    # Initialize a dictionary to hold summed PnL for each strategy and weekday
    summed_pnls = {
        strategy: {day: 0 for day in weekdays} for strategy in results.keys()
    }

    # Sum the PnL values for each strategy and weekday
    for strategy, df in results.items():
        for day in weekdays:
            summed_pnls[strategy][day] = df[df["Weekday"] == day]["Day PnL"].sum()

    # Prepare data for the bar chart
    x = np.arange(len(weekdays))  # the label locations
    width = 0.8 / len(results)

    fig, ax = plt.subplots(figsize=(10, 5))

    # Plot bars for each strategy
    for i, (strategy, pnl_dict) in enumerate(summed_pnls.items()):
        pnls = [pnl_dict[day] for day in weekdays]
        ax.bar(x + (i - (len(results) - 1) / 2) * width, pnls, width, label=strategy)

    # Add labels, title, and custom x-axis tick labels
    ax.set_ylabel("Total PnL")
    ax.set_title("PnL by Weekday")
    ax.set_xticks(x)
    ax.set_xticklabels(weekdays)
    ax.legend(
        loc="upper center", bbox_to_anchor=(0.5, -0.15), ncol=min(len(results), 4)
    )
    fig.subplots_adjust(bottom=0.2)
    plt.tight_layout()
    # buffer for saving data
    buf = BytesIO()
    plt.savefig(buf, dpi=150, bbox_inches="tight")
    buf.seek(0)
    # Convert PNG to base64 string
    img_str = base64.b64encode(buf.getvalue())
    plt.close()
    return img_str


def get_spx_gaps(start_date, end_date):
    start = start_date - dt.timedelta(
        10
    )  # make sure we get a few days before for calcs
    end = end_date + dt.timedelta(1)  # make sure we get the end date
    spx = yf.Ticker("^SPX")
    spx_history = spx.history(start=start, end=end, interval="1d")
    spx_history["Gap"] = spx_history["Open"] - spx_history["Close"].shift(1)
    spx_history["Gap%"] = spx_history["Gap"] / spx_history["Close"].shift(1) * 100
    return spx_history


def get_top_times(
    df_dict, strategy_settings, date: dt.datetime.date = None, top_n_override=0
) -> pd.DataFrame:
    portfolio_mode = "-SINGLE_MODE-" not in strategy_settings
    all_top_values = []
    top_n = 0
    # Iterate over each DataFrame in the dictionary
    for source, _df_dict in df_dict.items():
        strategy = "-SINGLE_MODE-" if not portfolio_mode else f"{source}.csv"
        try:
            settings = strategy_settings[strategy]
        except KeyError:
            # this is probably the separate put/call analysis we need to parse the source file
            strategy = f"{source.split('||')[1]}.csv"
            settings = strategy_settings[strategy]

        agg_type = "".join(word[0] for word in settings["-AGG_TYPE-"].split("-"))
        top_n = top_n_override if top_n_override else int(settings["-TOP_X-"])
        calc_type = settings["-CALC_TYPE-"]
        threshold = settings["-TOP_TIME_THRESHOLD-"] / 100
        df_orig = _df_dict["result_df"]

        if not date:
            df = df_orig.copy()
        else:
            date_timestamp = pd.Timestamp(date)
            if agg_type == "SM":
                # For semi-monthly, we need to check if the date is in the first or second half of the month
                if date_timestamp.day <= 15:
                    period_start = date_timestamp.replace(day=1)
                    period_end = date_timestamp.replace(day=15)
                else:
                    period_start = date_timestamp.replace(day=16)
                    period_end = date_timestamp.replace(
                        day=date_timestamp.days_in_month
                    )
                df = df_orig.loc[
                    (df_orig.index >= period_start) & (df_orig.index <= period_end), :
                ]
            else:
                period = pd.Period(date_timestamp, freq=agg_type)
                # df = df_orig.loc[df_orig.index == period, :]
                # this change allows to select the next available period in case the
                # current period is missing due to having some exclusions at that time.
                df = df_orig.loc[df_orig.index <= period, :].head(1)

        if df.index.name != "Date Range":
            df.set_index("Date Range", inplace=True)

        # Extract the first row of values
        try:
            if df.empty:
                continue
            first_row_values = df.iloc[0]
        except IndexError:
            # missing data for this month
            continue

        # Filter and sort the values in descending order and select the top n
        top_values = (
            first_row_values[first_row_values >= threshold]
            .sort_values(ascending=False)
            .head(top_n)
        )

        # Format values based on calc_type and add to the list of all top values
        for time, value in top_values.items():
            formatted_value = (
                f"{value:.2f}" if calc_type == "PnL" else f"{value * 100:.2f}%"
            )
            all_top_values.append(
                {
                    "Top Times": time,
                    "Values": formatted_value,
                    "Source": source,
                    "RawValue": value,  # Keep raw value for sorting
                }
            )

    # Convert the list to a DataFrame
    if all_top_values:
        result_df = pd.DataFrame(all_top_values)
    else:
        # empty
        result_df = pd.DataFrame(columns=["Top Times", "Values", "Source", "RawValue"])

    if not portfolio_mode:
        # Sort all values based on RawValue and select the overall top n
        result_df = result_df.loc[result_df.groupby("Top Times")["RawValue"].idxmax()]
        result_df = result_df.sort_values("RawValue", ascending=False).head(top_n)

    # Drop the RawValue column as it's no longer needed
    result_df = result_df.drop(columns=["RawValue"])

    return result_df


def import_news_events(filename) -> bool:
    global news_events
    """
    Import CSV downloaded from https://www.fxstreet.com/economic-calendar
    populates the dates for the releases in 'news_events' dict
    """

    def get_triple_witching_dates(
        start_year: int = 2000, end_year: int = dt.datetime.now().year
    ):
        """
        These are not in the calendar and must be calculated
        Triple witching ocurrs on the third friday of March, June, Sept, Dec
        """
        triple_witching_dates = []

        for year in range(start_year, end_year + 1):
            for month in [3, 6, 9, 12]:  # March, June, September, December
                # Get the first day of the month
                first_day = dt.datetime(year, month, 1)

                # Find the first Friday
                friday = first_day + dt.timedelta(
                    days=(4 - first_day.weekday() + 7) % 7
                )

                # Get the third Friday
                third_friday = friday + dt.timedelta(weeks=2)

                triple_witching_dates.append(third_friday.date())

        return triple_witching_dates

    def get_event(name):
        """
        Helper function to add news_event column to the df
        """
        keyword_dict = {
            "Consumer Price Index": "CPI",
            "Nonfarm Payrolls": "NFP",
            "ADP Employment": "ADP",
            "Initial Jobless Claims": "Initial Jobless Claims",
            "Retail Sales": "Retail Sales",
            "JOLT": "JOLT",
            "Unemployment": "Unemployment/NFP",
            "Producer Price Index": "PPI",
            "Gross Domestic Product": "GDP",
            "Personal Consumption Expenditures": "PCE",
            "Beige Book": "Beige Book",
            "ISM Manufacturing PMI": "ISM Manufacturing PMI",
            "ISM Services PMI": "ISM Services PMI",
            "Fed's Chair": "Fed Chair Speech",
            "FOMC Minutes": "FOMC Minutes",
            "Fed Interest Rate Decision": "FOMC",
            "Michigan Consumer Sentiment Index": "MI Consumer Sent.",
            "Chicago Purchasing": "Chicago PMI",
        }

        if "S&P" in name and "PMI" in name:
            return "S&P Global PMI"
        else:
            for keyword, event in keyword_dict.items():
                if keyword in name:
                    return event
            return ""

    # load csv, config dates and filter for US events
    try:
        df = pd.read_csv(filename)
    except Exception as e:
        return False
    if (
        "Start" not in df.columns
        or "Currency" not in df.columns
        or "Name" not in df.columns
    ):
        return False
    df.drop_duplicates(inplace=True)
    df["Start"] = pd.to_datetime(df["Start"])
    df = df[df["Currency"] == "USD"]
    df["news_event"] = df["Name"].apply(get_event)

    for news_event in news_events:
        if news_event == "Triple Witching":
            news_events[news_event] = get_triple_witching_dates()
        else:
            filtered_df = df[df["news_event"] == news_event]
            news_events[news_event] = sorted(filtered_df["Start"].dt.date.to_list())

    return True


def find_and_import_news_events():
    global news_events_loaded
    best_file = None
    max_rows = 0
    required_columns = set(["Id", "Start", "Name", "Impact", "Currency"])

    # Loop through all files in the current directory
    for filename in os.listdir("."):
        if filename.endswith(".csv"):
            try:
                # Try to read the CSV file
                df = pd.read_csv(filename)

                # Check if the required columns are present
                if set(df.columns) == required_columns:
                    rows = len(df)

                    # If this is the first valid file or has more rows than the previous best
                    if best_file is None or rows > max_rows:
                        best_file = filename
                        max_rows = rows
            except Exception as e:
                # If there's an error reading the file, skip it
                continue

    # If a valid file was found, import the news events
    if best_file:
        success = import_news_events(best_file)
        if success:
            news_events_loaded = True
            results_queue.put(
                ("-IMPORT_NEWS-", "News event list found and loaded sucessuflly!")
            )
            return
    results_queue.put(
        (
            "-IMPORT_NEWS-",
            "Could not locate news event csv.\nPlease select under options if needed",
        )
    )


def get_next_filename(path: str, base: str, ext: str) -> str:
    """
    Takes a path, base name, and extension.
    Checks if a filename already exists with that filename
    Adds (x) to the filename and returns the complete filename path
    """
    # Create filename
    filename = os.path.join(path, f"{base}{ext}")
    counter = 1
    while os.path.exists(filename):
        filename = os.path.join(path, f"{base}({counter}){ext}")
        counter += 1
    return filename


def is_BYOB_data(df: pd.DataFrame) -> bool:
    return df.columns[0] == "TradeID"


def load_data(
    file: str,
    weekday_exclusions: list = [],
) -> Tuple[pd.DataFrame, dt.datetime.date, dt.datetime.date]:
    """
    Takes a Trade Log CSV from either Option Omega or BYOB
    and returns a dataframe containing the trade data and
    the start and end dates of the dataset
    """
    # Load the CSV file
    try:
        delims = [",", ";", "\t", "|"]
        for delim in delims:
            df = pd.read_csv(file, delimiter=delim)
            if len(df.columns) > 1:
                break
        if len(df.columns) <= 1:
            # none of the delims worked
            raise UnicodeDecodeError
    except UnicodeDecodeError:
        sg.popup_no_border(
            "This does not appear to be a backtest results\nCSV from either OptionOmega"
            " or BYOB.\n\nPlease choose a different file"
        )
        return

    # remove duplicate rows in case human error in combining csv files
    df.drop_duplicates(inplace=True)

    # Determine which type of data, OptionOmega or BYOB
    is_byob = is_BYOB_data(df)
    if is_byob is None:
        sg.popup_no_border(
            "This does not appear to be a backtest results\nCSV from either OptionOmega"
            " or BYOB.\n\nPlease choose a different file"
        )
        return

    elif not is_byob:  # OO BT data
        # Convert 'Date Opened' to datetime format
        df["Date Opened"] = pd.to_datetime(df["Date Opened"])

        # Add EntryTime Column for analysis
        df["EntryTime"] = pd.to_datetime(
            df["Date Opened"].astype(str) + " " + df["Time Opened"]
        )

        # Add column for Option Right 'C' or 'P'
        df["OptionType"] = df["Legs"].apply(
            lambda x: x.split("|")[0].strip().split(" ")[4]
        )

    # Convert 'EntryTime' to datetime format
    df["EntryTime"] = pd.to_datetime(df["EntryTime"])

    # Add Day of week column
    df["Day of Week"] = df["EntryTime"].dt.day_name()

    # Create a 'Time' column
    df["Time"] = df["EntryTime"].dt.strftime("%H:%M:%S")

    # Sort by 'EntryTime'
    df.sort_values(["EntryTime"], inplace=True)

    # Determine start and end dates
    start_date = df["EntryTime"].min().date()
    end_date = df["EntryTime"].max().date()

    # Add temporary Date column for merging gap info
    df["Date"] = df["EntryTime"].dt.date

    # Get SPX historical open/close from yahoo finance and calc gaps
    spx_history = get_spx_gaps(start_date, end_date)
    if not spx_history.empty:
        spx_history = spx_history.reset_index()  # Reset index to make 'Date' a column
        spx_history["Date"] = spx_history["Date"].dt.date

        # drop the rows from spx_history that are not in df
        spx_history = spx_history[spx_history["Date"].isin(df["Date"].to_list())]

        # remove already present gap column from OO data
        df = df.drop(columns=["Gap"], errors="ignore")

        # Merge SPX gap information with the main dataframe
        df = pd.merge(df, spx_history[["Date", "Gap", "Gap%"]], on="Date", how="left")

    # Remove the temporary "Date" column if not needed
    df = df.drop(columns=["Date"])

    return (
        df[~df["Day of Week"].isin(weekday_exclusions)],
        start_date,
        end_date,
    )


def resize_image(image_path, size):
    """Resize the image to the specified size."""
    img = Image.open(image_path)
    img = img.resize(size, Image.LANCZOS)
    buf = BytesIO()
    img.save(buf, format="PNG")
    return buf.getvalue()


def resize_base64_image(base64_image, desired_height):
    # Decode the base64 string
    image_data = base64.b64decode(base64_image)

    # Open the image
    image = Image.open(BytesIO(image_data))
    # Calculate the scaling factor
    scale_factor = desired_height / image.height

    # Calculate new dimensions
    new_width = int(image.width * scale_factor)
    new_height = desired_height

    # Resize the image
    resized_image = image.resize((new_width, new_height), Image.LANCZOS)
    # Save the resized image to a bytes buffer
    buf = BytesIO()
    resized_image.save(buf, format="PNG")

    # Encode the resized image to base64
    return base64.b64encode(buf.getvalue())


@with_gc
def run_analysis_threaded(
    files_list,
    strategy_settings,
    open_files,
):
    # initialize df_dicts
    df_dicts = {}

    for file in files_list:
        strategy = (
            "-SINGLE_MODE-"
            if "-SINGLE_MODE-" in strategy_settings
            else os.path.basename(file)
        )
        settings = strategy_settings[strategy]
        result_dicts = create_excel_file(file, settings, open_files)

        # check for cancel flag to stop thread
        if cancel_flag.is_set():
            cancel_flag.clear()
            results_queue.put(("-BACKTEST_CANCELED-", ""))
            return

        source = os.path.splitext(os.path.basename(file))[0]
        for right_type, day_dict in result_dicts.items():
            if right_type not in df_dicts:
                df_dicts[right_type] = {
                    "All": {},
                    "Mon": {},
                    "Tue": {},
                    "Wed": {},
                    "Thu": {},
                    "Fri": {},
                }
            for day, df_dict in day_dict.items():
                df_dicts[right_type][day][source] = df_dict

    for _best in ["Best P/C", "Best P/C Gap Up", "Best P/C Gap Down"]:
        df_dicts[_best] = {
            "All": {},
            "Mon": {},
            "Tue": {},
            "Wed": {},
            "Thu": {},
            "Fri": {},
        }

        # combine the put and call dfs into 1 dict for dertmining the best time
        # from among both individual datasets
        for _right in ["Puts", "Calls"]:
            if _best.endswith("Gap Up"):
                _right += " Gap Up"
            elif _best.endswith("Gap Down"):
                _right += " Gap Down"

            if _right in df_dicts:
                for _day, _day_dict in df_dicts[_right].items():
                    for _source, _df_dict in _day_dict.items():
                        df_dicts[_best][_day][
                            f"{_right.removesuffix("s")}||{_source}"
                        ] = _df_dict

    results_queue.put(("-RUN_ANALYSIS_END-", df_dicts))
    return df_dicts


def save_settings(settings, settings_filename, values):
    for key in settings:
        settings[key] = values[key]
    os.makedirs(os.path.dirname(settings_filename), exist_ok=True)
    with open(settings_filename, "w") as f:
        json.dump(settings, f, indent=4)


def set_default_app_settings(app_settings):
    # Setup defaults if setting did not load/exist
    if "-THEME-" not in app_settings:
        app_settings["-THEME-"] = "Light"
    if "-AVG_PERIOD_1-" not in app_settings:
        app_settings["-AVG_PERIOD_1-"] = "4"
    if "-AVG_PERIOD_2-" not in app_settings:
        app_settings["-AVG_PERIOD_2-"] = "8"
    if "-PERIOD_1_WEIGHT-" not in app_settings:
        app_settings["-PERIOD_1_WEIGHT-"] = "25"
    if "-PERIOD_2_WEIGHT-" not in app_settings:
        app_settings["-PERIOD_2_WEIGHT-"] = "75"
    if "-TOP_X-" not in app_settings:
        app_settings["-TOP_X-"] = "5"
    if "-CALC_TYPE-" not in app_settings:
        app_settings["-CALC_TYPE-"] = "PCR"
    if "-AGG_TYPE-" not in app_settings:
        app_settings["-AGG_TYPE-"] = "Monthly"
    if "-OPEN_FILES-" not in app_settings:
        app_settings["-OPEN_FILES-"] = False
    if "-BACKTEST-" not in app_settings:
        app_settings["-BACKTEST-"] = False
    if "-START_VALUE-" not in app_settings:
        app_settings["-START_VALUE-"] = "100000"
    if "-START_DATE-" not in app_settings:
        app_settings["-START_DATE-"] = ""
    if "-END_DATE-" not in app_settings:
        app_settings["-END_DATE-"] = ""
    if "-EXPORT-" not in app_settings:
        app_settings["-EXPORT-"] = False
    if "-EXPORT_OO_SIG-" not in app_settings:
        app_settings["-EXPORT_OO_SIG-"] = False
    if "-SCALING-" not in app_settings:
        app_settings["-SCALING-"] = False
    if "-MIN_TRANCHES-" not in app_settings:
        app_settings["-MIN_TRANCHES-"] = "5"
    if "-MAX_TRANCHES-" not in app_settings:
        app_settings["-MAX_TRANCHES-"] = "5"
    if "-BP_PER-" not in app_settings:
        app_settings["-BP_PER-"] = "6000"
    if "-PORTFOLIO_MODE-" not in app_settings:
        app_settings["-PORTFOLIO_MODE-"] = False
    if "-TOP_TIME_THRESHOLD-" not in app_settings:
        app_settings["-TOP_TIME_THRESHOLD-"] = ""


def update_strategy_settings(values, settings):
    settings.update(
        {
            "-AVG_PERIOD_1-": values["-AVG_PERIOD_1-"],
            "-PERIOD_1_WEIGHT-": values["-PERIOD_1_WEIGHT-"],
            "-AVG_PERIOD_2-": values["-AVG_PERIOD_2-"],
            "-PERIOD_2_WEIGHT-": values["-PERIOD_2_WEIGHT-"],
            "-TOP_X-": values["-TOP_X-"],
            "-CALC_TYPE-": values["-CALC_TYPE-"],
            "-AGG_TYPE-": values["-AGG_TYPE-"],
            "-MIN_TRANCHES-": values["-MIN_TRANCHES-"],
            "-MAX_TRANCHES-": values["-MAX_TRANCHES-"],
            "-BP_PER-": values["-BP_PER-"],
            "-PASSTHROUGH_MODE-": values["-PASSTHROUGH_MODE-"],
            "-PORT_WEIGHT-": values["-PORT_WEIGHT-"],
            "-TOP_TIME_THRESHOLD-": values["-TOP_TIME_THRESHOLD-"],
        }
    )

    # Initialize option settings if they don't exist
    for option in [
        "-WEEKDAY_EXCLUSIONS-",
        "-NEWS_EXCLUSIONS-",
        "-PUT_OR_CALL-",
        "-IDV_WEEKDAY-",
        "-AUTO_EXCLUSIONS-",
        "-GAP_ANALYSIS-",
    ]:
        if option not in settings:
            settings[option] = []
    if "-APPLY_EXCLUSIONS-" not in settings:
        settings["-APPLY_EXCLUSIONS-"] = "Both"
    if "-GAP_THRESHOLD-" not in settings:
        settings["-GAP_THRESHOLD-"] = 0
    if "-GAP_TYPE-" not in settings:
        settings["-GAP_TYPE-"] = "%"


def validate_strategy_settings(strategy_settings):
    for strategy in strategy_settings:
        try:
            period1 = int(strategy_settings[strategy]["-AVG_PERIOD_1-"])
            period2 = int(strategy_settings[strategy]["-AVG_PERIOD_2-"])
            weight1 = float(strategy_settings[strategy]["-PERIOD_1_WEIGHT-"])
            weight2 = float(strategy_settings[strategy]["-PERIOD_2_WEIGHT-"])
            strategy_settings[strategy]["-AVG_PERIOD_1-"] = period1
            strategy_settings[strategy]["-AVG_PERIOD_2-"] = period2
            strategy_settings[strategy]["-PERIOD_1_WEIGHT-"] = weight1
            strategy_settings[strategy]["-PERIOD_2_WEIGHT-"] = weight2

            strategy_settings[strategy]["-TOP_X-"] = int(
                strategy_settings[strategy]["-TOP_X-"]
            )
            strategy_settings[strategy]["-MIN_TRANCHES-"] = int(
                strategy_settings[strategy]["-MIN_TRANCHES-"]
            )
            strategy_settings[strategy]["-MAX_TRANCHES-"] = int(
                strategy_settings[strategy]["-MAX_TRANCHES-"]
            )
            strategy_settings[strategy]["-BP_PER-"] = float(
                strategy_settings[strategy]["-BP_PER-"]
            )
            strategy_settings[strategy]["-PORT_WEIGHT-"] = float(
                strategy_settings[strategy]["-PORT_WEIGHT-"]
            )
            if strategy_settings[strategy]["-TOP_TIME_THRESHOLD-"]:
                strategy_settings[strategy]["-TOP_TIME_THRESHOLD-"] = float(
                    strategy_settings[strategy]["-TOP_TIME_THRESHOLD-"]
                )
            else:
                strategy_settings[strategy]["-TOP_TIME_THRESHOLD-"] = float("-inf")
        except ValueError:
            return (
                "Problem with values entered.\nPlease enter only positive whole numbers"
            )
        if period1 < 1 or period2 < 1 or period1 > period2:
            return "Please make sure both averaging periods are > 0\nand that Trailing Avg 2 is >= to Trailing Avg 1"
        if weight1 + weight2 != 100:
            return "Trailing Avg Weights should add up to 100"

    return True


@with_gc
def walk_forward_test(
    df_dicts: dict,
    path: str,
    strategy_settings: dict,
    start: dt.datetime.date = None,
    end: dt.datetime.date = None,
    initial_value: float = 100_000,
    use_scaling=False,
    export_trades=False,
    export_OO_sig=False,
):
    portfolio_mode = "-SINGLE_MODE-" not in strategy_settings
    start_date = dt.date.min
    passthrough_start_date = dt.date.min
    end_date = dt.date.max
    # loop through all the source dfs
    for source, df_dict in df_dicts["Put-Call Comb"]["All"].items():
        try:
            passthrough = strategy_settings[f"{source}.csv"]["-PASSTHROUGH_MODE-"]
        except KeyError as e:
            passthrough = False

        _start_date = df_dict["org_df"]["EntryTime"].min().date()
        _end_date = df_dict["org_df"]["EntryTime"].max().date()
        # find the latest start date
        if not passthrough:
            if _start_date > start_date:
                start_date = _start_date
        else:
            # we need to treat passthrough seperate since there is no
            # warm up period necessary.
            if _start_date > passthrough_start_date:
                passthrough_start_date = _start_date

        # find the earliest end date passthrough doesn't matter here
        if _end_date < end_date:
            end_date = _end_date

    max_long_avg_period = max(
        [
            max(settings["-AVG_PERIOD_1-"], settings["-AVG_PERIOD_2-"])
            for settings in strategy_settings.values()
        ]
    )
    date_adv = start_date + relativedelta(months=max_long_avg_period)
    warm_start = dt.date(date_adv.year, date_adv.month, 1)
    # use either the user input date or the first warmed up date
    if start:
        start_test_date = max(warm_start, start)
    else:
        start_test_date = warm_start
    end = end_date if end is None else end

    # check if any strats are using auto exclusion
    warm_up_date = start_test_date
    using_auto_exclusions = False
    for setting in strategy_settings.values():
        if setting["-AUTO_EXCLUSIONS-"]:
            # set the warmup date
            warm_up_date = warm_start + relativedelta(months=max_long_avg_period)
            using_auto_exclusions = True
            break
    # now we just need to see if the passthrough strats start later
    warm_up_date = max(warm_up_date, passthrough_start_date)

    if not portfolio_mode:
        settings = strategy_settings["-SINGLE_MODE-"]
        strats = ["All-P_C_Comb"]
        if settings["-PUT_OR_CALL-"] and settings["-IDV_WEEKDAY-"]:
            strats += ["Weekday-P_C_Comb", "All-Best_P_or_C", "Weekday-Best_P_or_C"]
        elif settings["-IDV_WEEKDAY-"]:
            strats.append("Weekday-P_C_Comb")
        elif settings["-PUT_OR_CALL-"]:
            strats.append("All-Best_P_or_C")
        if settings["-GAP_ANALYSIS-"]:
            for _strat in strats.copy():
                strats.append(f"{_strat}-Gap")
    else:
        strats = ["Portfolio"] + list(strategy_settings.keys())

    portfolio_metrics = {}
    for _strat in strats:
        portfolio_metrics[_strat] = {
            "Current Value": initial_value,
            "Highest Value": initial_value,
            "Max DD": 0.0,
            "Current DD": 0.0,
            "DD Days": 0,
            "Tranche Qtys": [],
            "Port Tranche Qtys": [],
            "Num Tranches": 1,
            "Port Num Tranches": 1,
            "trade log": pd.DataFrame(),
            "Tlog Auto Exclusions": (
                pd.DataFrame()
            ),  # for warm-up to calc EV for auto exclusions
            "Win Streak": 0,
            "Loss Streak": 0,
        }

    if portfolio_mode:
        port_dict = portfolio_metrics["Portfolio"]

    # init results
    results = {}
    for strategy in portfolio_metrics:
        results[strategy] = pd.DataFrame()

    # convert weekdays from full day name to short name. i.e. Monday to Mon
    day_list = [_day[:3] for _day in weekday_list]

    def determine_auto_skip(date: dt.date, tlog: pd.DataFrame, agg_type: str) -> bool:
        """
        Calculate the expected value of any news events that
        occur on the given date and return True if negative expectancy
        """
        current_weekday = date.strftime("%a")
        agg_type = (
            "ME"
            if agg_type == "Monthly"
            else "SME" if agg_type == "Semi-Monthly" else "W-SAT"
        )
        trade_log = tlog.copy()
        trade_log["EntryTime"] = pd.to_datetime(trade_log["EntryTime"])
        if is_BYOB_data(trade_log):
            trade_log["P/L"] = (
                trade_log["ProfitLossAfterSlippage"] * 100 - trade_log["CommissionFees"]
            )

        def _get_current_rolling_avg(df):
            # Set 'EntryTime' as the index
            df = df.set_index("EntryTime")
            # Resample to monthly or weekly frequency, summing the PNL
            aggregated_pnl = df["P/L"].resample(agg_type).sum()
            # Calculate the rolling average
            window = (
                max_long_avg_period
                if agg_type == "ME"
                else (
                    int(max_long_avg_period * 2)
                    if agg_type == "SME"
                    else int(max_long_avg_period * 4.33)
                )
            )
            rolling_avg_pnl = aggregated_pnl.rolling(
                window=window, min_periods=1
            ).mean()
            if not rolling_avg_pnl.empty:
                return rolling_avg_pnl.iloc[-1]
            else:
                return 0

        # find the events that occur on this date and calc the expectancy
        for event, date_list in news_events.items():
            if date in date_list:
                trade_log_filtered = trade_log[
                    trade_log["EntryTime"].dt.date.isin(date_list)
                ]
                if not trade_log_filtered.empty:
                    current_avg = _get_current_rolling_avg(trade_log_filtered)
                    if current_avg < 0:
                        # this event has negative expectancy, whole day can be skipped
                        return True

        # passed all news events, lets see if we skip the weekday
        trade_log_filtered = trade_log[
            trade_log["Day of Week"].str.contains(current_weekday)
        ]
        if not trade_log_filtered.empty:
            current_avg = _get_current_rolling_avg(trade_log_filtered)
            if current_avg < 0:
                # this dat has negative expectancy, whole day can be skipped
                return True
        return False

    if using_auto_exclusions:
        current_date = warm_start
    else:
        current_date = max(start_test_date, passthrough_start_date)

    # determine if we need to use gaps
    spx_history = pd.DataFrame()
    for setting in strategy_settings.values():
        if setting["-GAP_ANALYSIS-"]:
            spx_history = get_spx_gaps(current_date, end)
            if not spx_history.empty:
                # reset the index to just the date, dropping the time component
                spx_history = spx_history.reset_index()
                spx_history["Date"] = spx_history["Date"].dt.date
                spx_history = spx_history.set_index("Date")

    while current_date <= end:
        # check for cancel flag to stop thread
        if cancel_flag.is_set():
            cancel_flag.clear()
            results_queue.put(("-BACKTEST_CANCELED-", ""))
            return

        warmed_up = current_date >= warm_up_date

        if portfolio_mode:
            # reset daily pnl for portfolio
            port_dict["Current Day PnL"] = 0

        current_weekday = current_date.strftime("%a")
        for strat, strat_dict in portfolio_metrics.items():
            if portfolio_mode and strat == "Portfolio":
                # we don't trade the portfolio, it is just the combination of all individual strats
                continue
            elif portfolio_mode:
                settings = strategy_settings[strat]
            else:
                settings = strategy_settings["-SINGLE_MODE-"]

            # reset daily pnl for individual strategy
            strat_dict["Current Day PnL"] = 0

            day_exlusions = []
            news_date_exclusions = []
            if settings["-APPLY_EXCLUSIONS-"] != "Analysis":
                # we are applying exclusions to either the WF test or both the WF and Analysis
                day_exlusions = [_day[:3] for _day in settings["-WEEKDAY_EXCLUSIONS-"]]
                # get list of news event dates to skip.
                for release, date_list in news_events.items():
                    if release in settings["-NEWS_EXCLUSIONS-"]:
                        news_date_exclusions += date_list

            skip_day = False
            if warmed_up and using_auto_exclusions:
                skip_day = determine_auto_skip(
                    current_date,
                    strat_dict["Tlog Auto Exclusions"],
                    settings["-AGG_TYPE-"],
                )
            elif (
                current_weekday in day_exlusions
                or current_weekday not in day_list
                or current_date in news_date_exclusions
            ):
                skip_day = True

            if not settings["-PASSTHROUGH_MODE-"]:
                if use_scaling:

                    def determine_num_tranches(
                        min_tranches, max_tranches, num_contracts
                    ):
                        tranches = max_tranches
                        while True:
                            if num_contracts > tranches:
                                max_tranche_qty = int(num_contracts / tranches)
                                remain_qty = num_contracts - (
                                    tranches * max_tranche_qty
                                )
                                if remain_qty >= min_tranches or remain_qty == 0:
                                    # we're done we can stay at this number of tranches with
                                    # the remainder filling up another set of at least min tranches
                                    return tranches
                                else:
                                    # we need to take a tranche away so we can try to fill up at
                                    # least 1 full set at min amount
                                    if tranches - 1 < min_tranches:
                                        # we can't reduce any further, got with what we have
                                        # even if that means we will be adding contracts below the min
                                        return tranches
                                    else:
                                        tranches -= 1
                            else:
                                return num_contracts

                    def determine_tranche_qtys(tranches):
                        tranche_qtys = []
                        for x in range(tranches):
                            if x < num_contracts % tranches:
                                # this is where we add the remaining contracts after filling up all tranches
                                tranche_qtys.append(int(num_contracts / tranches) + 1)
                            else:
                                tranche_qtys.append(int(num_contracts / tranches))
                        return tranche_qtys

                    min_tranches = settings["-MIN_TRANCHES-"]
                    max_tranches = settings["-MAX_TRANCHES-"]
                    bp_per_contract = settings["-BP_PER-"]
                    num_contracts = int(strat_dict["Current Value"] / bp_per_contract)
                    tranches = determine_num_tranches(
                        min_tranches, max_tranches, num_contracts
                    )
                    strat_dict["Num Tranches"] = tranches
                    strat_dict["Tranche Qtys"] = determine_tranche_qtys(tranches)
                    if portfolio_mode:
                        weighted_value = (
                            port_dict["Current Value"] * settings["-PORT_WEIGHT-"] / 100
                        )
                        num_contracts = int(weighted_value / bp_per_contract)
                        tranches = determine_num_tranches(
                            min_tranches, max_tranches, num_contracts
                        )
                        strat_dict["Port Num Tranches"] = tranches
                        strat_dict["Port Tranche Qtys"] = determine_tranche_qtys(
                            tranches
                        )
                else:
                    # not scaling
                    num_contracts = settings["-TOP_X-"]
                    strat_dict["Num Tranches"] = num_contracts
                    strat_dict["Tranche Qtys"] = [1 for x in range(num_contracts)]
                    strat_dict["Port Num Tranches"] = num_contracts
                    strat_dict["Port Tranche Qtys"] = [1 for x in range(num_contracts)]

            if settings["-AGG_TYPE-"] == "Monthly":
                # date for best times should be the month prior as we don't know the future yet
                best_time_date = current_date - relativedelta(months=1)
            elif settings["-AGG_TYPE-"] == "Semi-Monthly":
                # grab from last half-month
                if current_date.day != 31:
                    best_time_date = current_date - relativedelta(days=15)
                else:
                    best_time_date = current_date - relativedelta(days=16)
            else:
                # grab from last week
                best_time_date = current_date - relativedelta(weeks=1)

            def log_pnl_and_trades(strat_dict, num_tranches, tranche_qtys):
                # determine gap info
                gap_str = ""
                if settings["-GAP_ANALYSIS-"]:
                    _gap_type = "Gap%" if settings["-GAP_TYPE-"] == "%" else "Gap"
                    try:
                        gap_value = spx_history.at[current_date, _gap_type]
                    except KeyError as e:
                        # probably a day market was not open (i.e. holiday)
                        gap_value = 0
                    if gap_value > settings["-GAP_THRESHOLD-"]:
                        gap_str = " Gap Up"
                    elif gap_value < -settings["-GAP_THRESHOLD-"]:
                        gap_str = " Gap Down"

                if portfolio_mode:
                    # determine which strat to use
                    if settings["-PUT_OR_CALL-"]:
                        _strat = "Best P/C"
                    else:
                        _strat = "Put-Call Comb"

                    _strat = _strat + gap_str  # add gap info onto the end of strat name

                    # determine which weekday to use
                    if settings["-IDV_WEEKDAY-"]:
                        _weekday = current_weekday
                    else:
                        _weekday = "All"

                else:
                    # determine strat name for df_dicts
                    if "P_C_Comb" in strat:
                        _strat = "Put-Call Comb"
                    else:
                        _strat = "Best P/C"

                    # determine gap type
                    if "Gap" not in strat:
                        gap_str = ""

                    _strat = _strat + gap_str  # add gap onto the end of strat name

                    # determine weekday type
                    if strat.startswith("All"):
                        _weekday = "All"
                    else:
                        _weekday = current_weekday

                # finally select the appropriate df_dict
                df_dict = df_dicts[_strat][_weekday]

                # get the best times for this strat
                best_times_df = get_top_times(
                    df_dict, strategy_settings, best_time_date, num_tranches
                )

                if portfolio_mode:
                    # filter out other sources since all sources are included
                    source = os.path.splitext(strat)[0]
                    best_times_df = (
                        best_times_df[best_times_df["Source"].str.endswith(source)]
                        .sort_values("Values", ascending=False)
                        .head(num_tranches)
                    )

                if settings["-PASSTHROUGH_MODE-"]:
                    # get all the times this traded on this date
                    source_df = df_dicts["Put-Call Comb"]["All"][source]["org_df"]
                    _filtered_df = source_df[
                        source_df["EntryTime"].dt.date == current_date
                    ]
                    best_times = (
                        _filtered_df["EntryTime"]
                        .dt.strftime("%H:%M:%S")
                        .unique()
                        .tolist()
                    )
                    # we don't determine the tranche qtys in passthrough mode, we just need
                    # to trade whaterver is in the trade log for that day.  Let's determine
                    # the qtys to trade for each trade in the log.
                    tranche_qtys = []
                    for _ in best_times:
                        if use_scaling:
                            current_value = strat_dict["Current Value"]
                            # calc total qty
                            total_qty = (
                                current_value
                                * settings["-PORT_WEIGHT-"]
                                / 100
                                / settings["-BP_PER-"]
                            )

                            # qty per trade
                            qty = int(total_qty / len(best_times))
                            tranche_qtys.append(max(qty, 1))
                        else:
                            tranche_qtys.append(1)
                else:  # no passthrough, use best times analysis
                    best_times = best_times_df["Top Times"].to_list()

                for time in best_times:
                    # get the qty for this tranche time
                    qty = tranche_qtys[best_times.index(time)]
                    full_dt = dt.datetime.combine(
                        current_date, dt.datetime.strptime(time, "%H:%M:%S").time()
                    )

                    if not settings["-PASSTHROUGH_MODE-"]:
                        # get the source df, we already have it from eariler for pass-through
                        source = best_times_df.loc[
                            best_times_df["Top Times"] == time, "Source"
                        ].values[0]
                        source_df = df_dict[source]["org_df"]

                    filtered_rows = source_df[source_df["EntryTime"] == full_dt].copy()

                    if filtered_rows.empty:
                        continue

                    filtered_rows["qty"] = qty
                    filtered_rows["source"] = source

                    if is_BYOB_data(source_df):
                        gross_pnl = (
                            filtered_rows["ProfitLossAfterSlippage"].sum() * 100 * qty
                        )
                        commissions = filtered_rows["CommissionFees"].sum() * qty
                        pnl = gross_pnl - commissions
                    else:
                        pnl = filtered_rows["P/L"].sum() * qty

                    # log trade
                    strat_dict["Tlog Auto Exclusions"] = pd.concat(
                        [strat_dict["Tlog Auto Exclusions"], filtered_rows],
                        ignore_index=True,
                    )
                    if warmed_up and not skip_day:
                        strat_dict["trade log"] = pd.concat(
                            [strat_dict["trade log"], filtered_rows], ignore_index=True
                        )
                        strat_dict["Current Value"] += pnl
                        strat_dict["Current Day PnL"] += pnl

            if current_weekday in day_list:
                # make sure its not the weekend
                num_tranches = strat_dict["Num Tranches"]
                tranche_qtys = strat_dict["Tranche Qtys"]
                log_pnl_and_trades(strat_dict, num_tranches, tranche_qtys)
                if portfolio_mode:
                    num_tranches = strat_dict["Port Num Tranches"]
                    tranche_qtys = strat_dict["Port Tranche Qtys"]
                    log_pnl_and_trades(port_dict, num_tranches, tranche_qtys)

            def calc_metrics(strat_dict: dict, strat: str, results: dict) -> None:
                # calc metrics and log the results for the day
                if strat_dict["Current Value"] >= strat_dict["Highest Value"]:
                    strat_dict["Highest Value"] = strat_dict["Current Value"]
                    strat_dict["DD Days"] = 0
                else:
                    # we are in Drawdown
                    dd = (
                        strat_dict["Highest Value"] - strat_dict["Current Value"]
                    ) / strat_dict["Highest Value"]
                    strat_dict["Current DD"] = dd
                    if dd > strat_dict["Max DD"]:
                        strat_dict["Max DD"] = dd
                    strat_dict["DD Days"] += 1

                if strat_dict["Current Day PnL"] > 0:
                    strat_dict["Win Streak"] += 1
                    strat_dict["Loss Streak"] = 0
                elif strat_dict["Current Day PnL"] < 0:
                    # tie does not change any streak
                    strat_dict["Win Streak"] = 0
                    strat_dict["Loss Streak"] += 1

                new_row = pd.DataFrame(
                    [
                        {
                            "Date": current_date,
                            "Current Value": strat_dict["Current Value"],
                            "Highest Value": strat_dict["Highest Value"],
                            "Max DD": strat_dict["Max DD"],
                            "Current DD": strat_dict["Current DD"],
                            "DD Days": strat_dict["DD Days"],
                            "Day PnL": strat_dict["Current Day PnL"],
                            "Win Streak": strat_dict["Win Streak"],
                            "Loss Streak": strat_dict["Loss Streak"],
                            "Initial Value": initial_value,
                            "Weekday": current_weekday,
                        }
                    ]
                )
                results[strat] = pd.concat([results[strat], new_row], ignore_index=True)

            if warmed_up and not skip_day:
                calc_metrics(strat_dict, strat, results)

            if skip_day:
                # this is a skip day just increment the DD days if needed
                if strat_dict["DD Days"] > 0:
                    strat_dict["DD Days"] += 1
                if portfolio_mode and port_dict["DD Days"] > 0:
                    port_dict["DD Days"] += 1

        # calculate all the stats for the portfolio now that all other strats have traded
        if portfolio_mode and warmed_up and not skip_day:
            calc_metrics(port_dict, "Portfolio", results)

        current_date += dt.timedelta(1)

    for strat in portfolio_metrics:
        if not results[strat].empty:
            results[strat]["Date"] = pd.to_datetime(results[strat]["Date"])
            uuid_str = str(uuid.uuid4())[:8]
            if export_trades:
                base_filename = f"{strat} - TradeLog_{uuid_str}"
                ext = ".csv"
                export_filename = get_next_filename(path, base_filename, ext)
                portfolio_metrics[strat]["trade log"].to_csv(
                    export_filename, index=False
                )
            if export_OO_sig:
                base_filename = f"{strat} - OO_Signal_File_{uuid_str}"
                ext = ".csv"
                export_filename = get_next_filename(path, base_filename, ext)
                export_oo_sig_file(
                    portfolio_metrics[strat]["trade log"], export_filename
                )
    results_queue.put(("-BACKTEST_END-", results))
    return results


@with_gc
def options_window(settings) -> None:
    global news_events_loaded
    dpi_scale = get_dpi_scale()
    BASE_HEIGHT = 40
    scaled_height = int(BASE_HEIGHT * dpi_scale)
    weekday_exclusion_checkboxes = [
        Checkbox(
            day,
            day in settings["-WEEKDAY_EXCLUSIONS-"],
            key=day,
            font=font,
            size=(6, 1),
        )
        for day in weekday_list
    ]
    news_exclusion_checkboxes = [
        Checkbox(
            release,
            release in settings["-NEWS_EXCLUSIONS-"],
            key=release,
            font=font,
            size=(11, 1),
        )
        for release in news_events
    ]
    # break into rows of 3
    news_exclusion_checkboxes = chunk_list(news_exclusion_checkboxes, 3)
    fxstreet_link = "https://www.fxstreet.com/economic-calendar"
    donate_paypal_link = "https://www.paypal.com/donate?hosted_button_id=ZDZEXUHMZR9RJ"
    donate_venmo_link = "https://www.venmo.com/u/excessivechaos"
    layout = [
        [
            sg.Text("Economic Calendar CSV file (", pad=(0, 0)),
            sg.Text(
                fxstreet_link,
                pad=(0, 0),
                enable_events=True,
                font=font + ("underline",),
                text_color="blue",
                key=("-LINK-", fxstreet_link),
            ),
            sg.Text(")", pad=(0, 0)),
        ],
        [
            sg.Input(
                "Loaded" if news_events_loaded else "",
                key="-FILE-",
                expand_x=True,
            ),
            sg.Button("Browse"),
        ],
        [
            sg.Frame(
                "Exclude Weekday",
                [weekday_exclusion_checkboxes],
                expand_x=True,
            ),
        ],
        [
            sg.Frame(
                "Exclude news",
                news_exclusion_checkboxes,
                expand_x=True,
            ),
        ],
        [
            sg.Frame(
                "Analysis Options",
                [
                    [
                        sg.Text("Apply Exclusions to:", pad=((5, 1), 5)),
                        sg.Combo(
                            ["Both", "Analysis", "Walk Forward Test"],
                            settings["-APPLY_EXCLUSIONS-"],
                            key="-APPLY_EXCLUSIONS-",
                            font=font,
                            tooltip="Apply the excluded events/weekdays to the analysis\nof best times, or just the walk-forward test, or both.",
                            pad=(0, 5),
                            readonly=True,
                        ),
                    ],
                    [
                        Checkbox(
                            "Put or Call",
                            settings["-PUT_OR_CALL-"],
                            key="-PUT_OR_CALL-",
                            font=font,
                            size=(6, 1),
                            tooltip="Compare selecting the best times to trade only puts or calls",
                        ),
                        Checkbox(
                            "Individual Weekday",
                            settings["-IDV_WEEKDAY-"],
                            key="-IDV_WEEKDAY-",
                            font=font,
                            size=(10, 1),
                            tooltip="Compare selecting the best times for each specific weekday to trade for that weekday",
                        ),
                        Checkbox(
                            "Auto Exclusions",
                            settings["-AUTO_EXCLUSIONS-"],
                            key="-AUTO_EXCLUSIONS-",
                            font=font,
                            size=(10, 1),
                            pad=(5, 5),
                            tooltip="Allow Walk-Forward test to determine which events to exclude\nbased on whether the event has -EV from prior lookback period.\nNote: This will require an additional warmup period.",
                        ),
                    ],
                    [sg.HorizontalSeparator()],
                    [
                        Checkbox(
                            "Use Gap Analysis",
                            settings["-GAP_ANALYSIS-"],
                            key="-GAP_ANALYSIS-",
                            font=font,
                            size=(10, 1),
                            tooltip="Look for the best times for gap up and down days",
                        ),
                        sg.Text("Threshold:"),
                        sg.Input(
                            settings["-GAP_THRESHOLD-"],
                            size=(5, 1),
                            key="-GAP_THRESHOLD-",
                        ),
                        sg.Combo(
                            ["%", "Points"],
                            settings["-GAP_TYPE-"],
                            readonly=True,
                            key="-GAP_TYPE-",
                        ),
                    ],
                ],
                expand_x=True,
            ),
        ],
        [
            sg.Ok(),
            sg.Cancel(),
            sg.Push(),
            sg.Button(
                image_data=resize_base64_image(
                    donate_paypal_logo, int(scaled_height * 1.5)
                ),
                button_color=sg.theme_background_color(),
                border_width=0,
                key=("-LINK-", donate_paypal_link),
                pad=(0, 0),
            ),
            sg.Button(
                image_data=resize_base64_image(donate_venmo_logo, scaled_height),
                button_color=sg.theme_background_color(),
                border_width=0,
                key=("-LINK-", donate_venmo_link),
                pad=(0, 0),
            ),
        ],
    ]

    window = sg.Window(
        "Options",
        layout,
        no_titlebar=False,
        # size=window_size,
        finalize=True,
        modal=True,
        resizable=True,
    )
    Checkbox.initial(window)
    # let window be made so the length is auto set
    # the width always fills the screen when using the custom
    # checkbox class, so we need to change the size.  Allowing
    # the window to self size first we can get the correct height
    window_height = window.size[1]
    window_width = int(650 * dpi_scale)
    window.TKroot.geometry(f"{window_width}x{window_height}")

    # Now we need to move the window since it opens all the way left.
    # We will position it at the cursor location since the options button is on the right
    mouse_x = window.TKroot.winfo_pointerx()
    mouse_y = window.TKroot.winfo_pointery()
    x_cordinate = mouse_x - window_width
    y_cordinate = mouse_y

    # Ensure the window is fully visible
    x_cordinate = max(0, min(x_cordinate, screen_size[0] - window_width))
    y_cordinate = max(0, min(y_cordinate, screen_size[1] - window_height))

    # Set the window position
    window.TKroot.geometry(f"+{x_cordinate}+{y_cordinate}")

    while True:
        event, values = window.read()
        if event in (sg.WIN_CLOSED, "Cancel"):
            break

        elif event == "Browse":
            news_file = sg.popup_get_file(
                "",
                file_types=(("CSV Files", "*.csv"),),
                multiple_files=False,
                no_window=True,
            )
            window["-FILE-"].update(news_file)

        elif event == "Ok":
            settings["-WEEKDAY_EXCLUSIONS-"] = [
                day for day in weekday_list if values[day]
            ]
            settings["-NEWS_EXCLUSIONS-"] = [
                release for release in news_events if values[release]
            ]
            settings["-PUT_OR_CALL-"] = values["-PUT_OR_CALL-"]
            settings["-IDV_WEEKDAY-"] = values["-IDV_WEEKDAY-"]
            settings["-GAP_ANALYSIS-"] = values["-GAP_ANALYSIS-"]
            try:
                settings["-GAP_THRESHOLD-"] = float(values["-GAP_THRESHOLD-"])
            except ValueError:
                sg.popup_no_border("Please correct Gap Threshold value")
                continue
            settings["-GAP_TYPE-"] = values["-GAP_TYPE-"]
            settings["-APPLY_EXCLUSIONS-"] = values["-APPLY_EXCLUSIONS-"]
            settings["-AUTO_EXCLUSIONS-"] = values["-AUTO_EXCLUSIONS-"]
            if values["-FILE-"] and values["-FILE-"] != "Loaded":
                result = import_news_events(values["-FILE-"])
                if result:
                    news_events_loaded = True
                    break
                else:
                    sg.popup_no_border(
                        "This does not appear to be a CSV from\nhttps://www.fxstreet.com/economic-calendar"
                    )
                    continue
            else:
                break

        elif event[0] == "-LINK-":
            webbrowser.open(event[1])
    window.close()
    Checkbox.clear_elements()


def main():
    # try to load news events if csv found
    threading.Thread(target=find_and_import_news_events, daemon=True).start()

    # load default settings or last used
    app_settings = {}
    settings_filename = os.path.join(os.path.curdir, "data", "tta_settings.json")
    if os.path.exists(settings_filename):
        try:
            with open(settings_filename, "r") as f:
                app_settings = json.load(f)
        except json.JSONDecodeError:
            # delete bad file
            results_queue.put(
                (
                    "-ERROR-",
                    "Error loading tta_settings.json\nDeleting corrupt file and\nfalling back to defaults",
                )
            )
            try:
                os.remove(settings_filename)
            except:
                results_queue.put(
                    (
                        "-ERROR-",
                        "Could not delete corrupt tta_settings.json file.\nPlease remove manually from data directory",
                    )
                )
                pass
    # setup defaults if setting did not load/exist
    set_default_app_settings(app_settings)

    sg.theme(themes[app_settings["-THEME-"]])
    sg.theme_button_color(button_color)  # override button color

    def get_main_window(values=None, old_window=None):
        tg_strat_layout = []
        for tg_strat in ["Put-Call Comb", "Best P/C", "Puts", "Calls"]:
            tg_gap_layout = []
            for tg_gap in ["All", "Gap Up", "Gap Down"]:
                tg_day_layout = []
                for day in ["All", "Mon", "Tue", "Wed", "Thu", "Fri"]:
                    tab = sg.Tab(
                        day,
                        [
                            [
                                sg.Table(
                                    (
                                        old_window.key_dict[
                                            f"-TABLE_{tg_strat}_{tg_gap}_{day}-"
                                        ].Values
                                        if old_window
                                        else ""
                                    ),
                                    ["Top Times", "Avg", "Source File"],
                                    key=f"-TABLE_{tg_strat}_{tg_gap}_{day}-",
                                    expand_x=True,
                                    auto_size_columns=True,
                                    # background_color="white",
                                    # alternating_row_color="darkgrey",
                                    # header_text_color="black",
                                    # header_background_color="lightblue",
                                )
                            ]
                        ],
                        expand_x=True,
                    )
                    tg_day_layout.append(tab)
                gap_group_tab = sg.Tab(
                    tg_gap,
                    [[sg.TabGroup([tg_day_layout], expand_x=True)]],
                    expand_x=True,
                )
                tg_gap_layout.append(gap_group_tab)
            main_group_tab = sg.Tab(
                tg_strat,
                [[sg.TabGroup([tg_gap_layout], expand_x=True)]],
                expand_x=True,
            )
            tg_strat_layout.append(main_group_tab)

        chart_tab = sg.Tab(
            "Charts",
            [
                [
                    sg.TabGroup(
                        [
                            [
                                sg.Tab(
                                    "PnL",
                                    [
                                        [
                                            sg.Table(
                                                (
                                                    old_window.key_dict[
                                                        "-PNL_TABLE_CHART-"
                                                    ].Values
                                                    if old_window
                                                    else ""
                                                ),
                                                [
                                                    "Strategy",
                                                    "Final Value",
                                                    "Profit",
                                                    "Total Return",
                                                    "CAGR",
                                                    "Max DD",
                                                    "Max DD Days",
                                                    "W Strk",
                                                    "L Strk",
                                                    "High Month",
                                                    "Low Month",
                                                    "MAR",
                                                    "Sharpe",
                                                ],
                                                key="-PNL_TABLE_CHART-",
                                                expand_x=True,
                                                num_rows=4,
                                                auto_size_columns=True,
                                                # background_color="lightgrey",
                                                # alternating_row_color="darkgrey",
                                                # header_text_color="black",
                                                # header_background_color="lightblue",
                                            )
                                        ],
                                        [
                                            sg.Image(
                                                key="-PNL_CHART-",
                                                size=(
                                                    int(screen_size[0] * 0.25),
                                                    int(screen_size[1] * 0.25),
                                                ),
                                                expand_x=True,
                                                expand_y=True,
                                            )
                                        ],
                                    ],
                                ),
                                sg.Tab(
                                    "PnL by Weekday",
                                    [
                                        [
                                            sg.Image(
                                                key="-WEEKDAY_PNL_CHART-",
                                                size=(
                                                    int(screen_size[0] * 0.25),
                                                    int(screen_size[1] * 0.25),
                                                ),
                                                expand_x=True,
                                                expand_y=True,
                                            )
                                        ],
                                    ],
                                ),
                                sg.Tab(
                                    "Monthly PnL",
                                    [
                                        [
                                            sg.Image(
                                                key="-MONTHLY_PNL_CHART-",
                                                size=(
                                                    int(screen_size[0] * 0.25),
                                                    int(screen_size[1] * 0.25),
                                                ),
                                                expand_x=True,
                                                expand_y=True,
                                            )
                                        ],
                                    ],
                                ),
                                sg.Tab(
                                    "PnL by News Event",
                                    [
                                        [
                                            sg.Image(
                                                key="-NEWS_PNL_CHART-",
                                                size=(
                                                    int(screen_size[0] * 0.25),
                                                    int(screen_size[1] * 0.25),
                                                ),
                                                expand_x=True,
                                                expand_y=True,
                                            )
                                        ],
                                    ],
                                ),
                                sg.Tab(
                                    "Avg PnL per News Event",
                                    [
                                        [
                                            sg.Image(
                                                key="-NEWS_AVG_PNL_CHART-",
                                                size=(
                                                    int(screen_size[0] * 0.25),
                                                    int(screen_size[1] * 0.25),
                                                ),
                                                expand_x=True,
                                                expand_y=True,
                                            )
                                        ],
                                    ],
                                ),
                                sg.Tab(
                                    "Correlation Matrix",
                                    [
                                        [
                                            sg.Image(
                                                key="-CORRELATION_MATRIX-",
                                                size=(
                                                    int(screen_size[0] * 0.25),
                                                    int(screen_size[1] * 0.25),
                                                ),
                                                expand_x=True,
                                                expand_y=True,
                                            )
                                        ],
                                    ],
                                    key="-CORRELATION_MATRIX_TAB-",
                                    visible=(
                                        old_window["-CORRELATION_MATRIX_TAB-"].visible
                                        if old_window
                                        else False
                                    ),
                                ),
                            ]
                        ],
                        expand_x=True,
                        expand_y=True,
                    )
                ]
            ],
        )
        tg_strat_layout.append(chart_tab)

        layout = [
            [
                sg.Button("Analyze", pad=(5, 10), bind_return_key=True),
                sg.Text("  "),
                sg.pin(
                    sg.ProgressBar(
                        100,
                        orientation="h",
                        size=(50, 30),
                        key="-PROGRESS-",
                        expand_x=True,
                        visible=False,
                    ),
                ),
                sg.pin(sg.Button("Cancel", pad=(20, 0), visible=False)),
                sg.Push(),
                sg.Button("CSV Merger"),
                sg.Combo(
                    list(themes),
                    default_value=app_settings["-THEME-"],
                    key="-THEME-",
                    enable_events=True,
                    readonly=True,
                ),
                sg.Text(__version__),
            ],
            [sg.Text("Select trade log CSV file:")],
            [
                sg.Input(
                    key="-FILE-",
                    expand_x=True,
                ),
                sg.Button("Browse"),
            ],
            [
                Checkbox(
                    "Portfolio Mode",
                    app_settings["-PORTFOLIO_MODE-"],
                    key="-PORTFOLIO_MODE-",
                    size=(12, 1),
                    enable_events=True,
                ),
                sg.pin(
                    sg.Combo(
                        [],
                        key="-STRATEGY_SELECT-",
                        readonly=True,
                        visible=app_settings["-PORTFOLIO_MODE-"],
                        enable_events=True,
                        size=(50, 1),
                    )
                ),
                sg.pin(
                    Checkbox(
                        "Pass-through Mode",
                        False,
                        key="-PASSTHROUGH_MODE-",
                        size=(14, 1),
                        tooltip="This will skip analysis and allow the trades\nto pass-through as is to the walk-forward test.\nThis can be used for adding non-tranche\nstrategies to the portfolio for analysis",
                        visible=app_settings["-PORTFOLIO_MODE-"],
                    )
                ),
                sg.Push(),
                sg.Button("Options", button_color="green"),
            ],
            [
                sg.Frame(
                    "",
                    [
                        [
                            sg.Text(
                                "Trailing Avg 1:",
                                tooltip="Number of months for first averaging period.\nNote: should be the shorter period",
                            ),
                            sg.Input(
                                app_settings["-AVG_PERIOD_1-"],
                                key="-AVG_PERIOD_1-",
                                size=(3, 1),
                                justification="c",
                                tooltip="Number of months for first averaging period.\nNote: should be the shorter period",
                            ),
                            sg.Text("Months "),
                            sg.Text(
                                "Weight:",
                                tooltip="Weight in % for first avg period\nNote: Set to 100 for this and 0 for 2nd if only using 1 period",
                            ),
                            sg.Input(
                                app_settings["-PERIOD_1_WEIGHT-"],
                                key="-PERIOD_1_WEIGHT-",
                                size=(3, 1),
                                justification="c",
                                tooltip="Weight in % for first avg period\nNote: Set to 100 for this and 0 for 2nd if only using 1 period",
                            ),
                            sg.Text("   "),
                            sg.Text(
                                "Trailing Avg 2:",
                                tooltip="Number of months for second averaging period.\nNote: should be the longer period or same as 1",
                            ),
                            sg.Input(
                                app_settings["-AVG_PERIOD_2-"],
                                key="-AVG_PERIOD_2-",
                                size=(3, 1),
                                justification="c",
                                tooltip="Number of months for second averaging period.\nNote: should be the longer period or same as 1",
                            ),
                            sg.Text("Months "),
                            sg.Text(
                                "Weight:",
                                tooltip="Weight in % for second avg period\nNote: Set to 0 to only use the 1st period",
                            ),
                            sg.Input(
                                app_settings["-PERIOD_2_WEIGHT-"],
                                key="-PERIOD_2_WEIGHT-",
                                size=(3, 1),
                                justification="c",
                                tooltip="Weight in % for second avg period\nNote: Set to 0 to only use the 1st period",
                            ),
                        ],
                        [
                            sg.Text(
                                "Select Top",
                                pad=(5, 5),
                                tooltip="Highlight the top n times for each month in the heatmap.\nWill also display the top n times below",
                            ),
                            sg.Input(
                                app_settings["-TOP_X-"],
                                key="-TOP_X-",
                                size=(2, 1),
                                pad=(0, 0),
                                justification="c",
                                tooltip="Highlight the top n times for each month in the heatmap.\nWill also display the top n times below",
                            ),
                            sg.Text("Time Tranches", pad=(5, 0)),
                            sg.Text("Above:"),
                            sg.Input(
                                app_settings["-TOP_TIME_THRESHOLD-"],
                                key="-TOP_TIME_THRESHOLD-",
                                size=(4, 1),
                                justification="c",
                            ),
                            sg.Text(
                                app_settings["-CALC_TYPE-"],
                                key="-CALC_TYPE_TEXT-",
                                pad=(0, 0),
                            ),
                            sg.Text("   Averaging Mode"),
                            sg.Combo(
                                ["PCR", "PnL"],
                                app_settings["-CALC_TYPE-"],
                                key="-CALC_TYPE-",
                                readonly=True,
                                enable_events=True,
                            ),
                            sg.Text(
                                "   Aggregation Period",
                                tooltip="Aggregate the results into monthly averages or weekly\nIf doing a walkforward test the top times will be updated at this frequency.",
                            ),
                            sg.Combo(
                                ["Monthly", "Semi-Monthly", "Weekly"],
                                app_settings["-AGG_TYPE-"],
                                key="-AGG_TYPE-",
                                tooltip="Aggregate the results into monthly averages or weekly\nIf doing a walkforward test the top times will be updated at this frequency.",
                                readonly=True,
                            ),
                            sg.Push(),
                            Checkbox(
                                "Open Excel files after creation",
                                app_settings["-OPEN_FILES-"],
                                key="-OPEN_FILES-",
                                size=(20, 1),
                            ),
                        ],
                    ],
                    expand_x=True,
                )
            ],
            [
                sg.Frame(
                    "",
                    [
                        [
                            Checkbox(
                                "Perform walk-forward backtest",
                                app_settings["-BACKTEST-"],
                                key="-BACKTEST-",
                                size=(19, 1),
                                tooltip="Out of sample/walk forward test.  Optimize times for prior lookback period\nand test outcome in the following month (out of sample).\nWalk forward to the next month and re-optomize times.",
                            ),
                            sg.Text(
                                "Starting Value",
                                tooltip="Porfolio Value to start from.  If using scaling the BP per contract\nwill be divided by this amount to determine the number of contracts to trade",
                            ),
                            sg.Input(
                                app_settings["-START_VALUE-"],
                                size=(10, 1),
                                key="-START_VALUE-",
                                justification="r",
                                tooltip="Porfolio Value to start from.  If using scaling the BP per contract\nwill be divided by this amount to determine the number of contracts to trade",
                            ),
                            sg.Text(
                                "   Start Date",
                                tooltip="Date to start test from. Leave blank to automatically\nselect the earliest available start date from the available data",
                            ),
                            sg.Input(
                                app_settings["-START_DATE-"],
                                key="-START_DATE-",
                                size=(12, 1),
                                justification="c",
                                tooltip="Date to start test from. Leave blank to automatically\nselect the earliest available start date from the available data",
                            ),
                            sg.Text(
                                " End Date",
                                tooltip="Date to end test. Leave blank to automatically\nselect the latest available end date from the available data",
                            ),
                            sg.Input(
                                app_settings["-END_DATE-"],
                                key="-END_DATE-",
                                size=(12, 1),
                                justification="c",
                                tooltip="Date to end test. Leave blank to automatically\nselect the latest available end date from the available data",
                            ),
                            sg.Push(),
                            Checkbox(
                                "Export Trades to CSV",
                                app_settings["-EXPORT-"],
                                key="-EXPORT-",
                                size=(16, 1),
                            ),
                        ],
                        [
                            Checkbox(
                                "Use Scaling",
                                app_settings["-SCALING-"],
                                key="-SCALING-",
                                size=(10, 1),
                                tooltip="Uses scaling logic to determine the number of contracts\nto trade each day of the backtest based on current portfolio value\nand the BP per contract.",
                            ),
                            sg.Text(
                                "Min Tranches",
                                tooltip="When using scaling, this the minimum number of tranche times",
                            ),
                            sg.Input(
                                app_settings["-MIN_TRANCHES-"],
                                key="-MIN_TRANCHES-",
                                size=(3, 1),
                                justification="c",
                                tooltip="When using scaling, this the minimum number of tranche times",
                            ),
                            sg.Text(
                                "   Max Tranches",
                                tooltip="When using scaling, this the maximum number of tranche times.\nAdditonal contracts over this amount will be distributed among the available tranche times.",
                            ),
                            sg.Input(
                                app_settings["-MAX_TRANCHES-"],
                                key="-MAX_TRANCHES-",
                                size=(3, 1),
                                justification="c",
                                tooltip="When using scaling, this the maximum number of tranche times.\nAdditonal contracts over this amount will be distributed among the available tranche times.",
                            ),
                            sg.Text(
                                "   BP Per Contract",
                                tooltip="Amount of buying power to use for each contract.  This is only used to determine\nthe total number of contracts to trade each day when using scaling.",
                            ),
                            sg.Input(
                                app_settings["-BP_PER-"],
                                key="-BP_PER-",
                                size=(6, 1),
                                justification="r",
                                tooltip="Amount of buying power to use for each contract.  This is only used to determine\nthe total number of contracts to trade each day when using scaling.",
                            ),
                            sg.pin(
                                sg.Text(
                                    "Portfolio Weight",
                                    visible=app_settings["-PORTFOLIO_MODE-"],
                                    key="-PORT_WEIGHT_TEXT1-",
                                )
                            ),
                            sg.pin(
                                sg.Input(
                                    "100",
                                    key="-PORT_WEIGHT-",
                                    size=(5, 1),
                                    justification="c",
                                    tooltip="The weight the selected strategy will have in the portfolio rebalanced daily.",
                                    visible=app_settings["-PORTFOLIO_MODE-"],
                                )
                            ),
                            sg.pin(
                                sg.Text(
                                    "%",
                                    pad=(0, 0),
                                    visible=app_settings["-PORTFOLIO_MODE-"],
                                    key="-PORT_WEIGHT_TEXT2-",
                                )
                            ),
                            sg.Push(),
                            Checkbox(
                                "Create OO Signal File",
                                app_settings["-EXPORT_OO_SIG-"],
                                key="-EXPORT_OO_SIG-",
                                size=(16, 1),
                            ),
                        ],
                    ],
                    expand_x=True,
                )
            ],
            [
                sg.TabGroup(
                    [tg_strat_layout],
                    expand_x=True,
                    key="-TAB_GROUP-",
                )
            ],
        ]
        if old_window:
            # create new window with same size and location
            window_size = old_window.size
            window_position = old_window.current_location(False)
        else:
            window_size = (int(screen_size[0] * 0.7), int(screen_size[1] * 0.8))
            window_position = (None, None)
        window = sg.Window(
            "Tranche Time Analyzer",
            layout,
            size=window_size,
            resizable=True,
            finalize=True,
            location=window_position,
        )
        window["-PROGRESS-"].Widget.config(mode="indeterminate")
        Checkbox.initial(window)

        # reselect previously selected tabs
        if old_window:
            # get the currently selected tab
            tab_group = old_window["-TAB_GROUP-"]
            selected = tab_group.get()
            selected_id = [
                "Put-Call Comb",
                "Best P/C",
                "Puts",
                "Calls",
                "Charts",
            ].index(selected)
            window["-TAB_GROUP-"].Widget.select(selected_id)

        # If we have previous values, update the window
        if values:
            for key in values:
                if key in window.AllKeysDict:
                    element = window[key]
                    if isinstance(element, sg.Table):
                        # For Table elements, we need to update the values differently
                        data = old_window.key_dict[key].Values
                        if key == "-PNL_TABLE_CHART-":
                            element.update(values=data, num_rows=min(len(data), 4))
                        else:
                            element.update(values=data, num_rows=len(data))

                    elif isinstance(element, sg.Checkbox):
                        # For Checkbox elements, we need to use the 'value' parameter
                        element.update(value=values[key])
                    elif not isinstance(element, sg.TabGroup):
                        # For most other elements, we can use the 'value' parameter
                        if key == "-STRATEGY_SELECT-":
                            element.update(values=old_window[key].Values)
                        try:
                            element.update(value=values[key])
                        except:
                            pass
        return window

    window = get_main_window()
    error = False
    chart_images = {}
    strategy_settings = {}
    test_running = False
    while True:
        event, values = window.read(timeout=100)
        if event == sg.WIN_CLOSED:
            break
        elif event == "Cancel" and test_running:
            # button will not do anything for normal analysis
            cancel_flag.set()
            window["Cancel"].update("Canceling...", disabled=True)

        elif event == "CSV Merger":
            csv_merger_window()

        elif event == "Options":
            if values["-PORTFOLIO_MODE-"]:
                selected_strategy = values["-STRATEGY_SELECT-"]
            else:
                selected_strategy = "-SINGLE_MODE-"
            if selected_strategy:
                options_window(strategy_settings[selected_strategy])
            else:
                sg.popup_no_border("Please select a strategy first")

        elif event == "Analyze":
            files_list = values["-FILE-"].split(";")
            for file in files_list:
                file_ext = os.path.splitext(file)[1].lower()
                if file_ext != ".csv":
                    sg.popup_no_border(
                        "One or more of the selected files\ndo not appear to be a csv file!"
                    )
                    error = True
                    break
            if error:
                error = False  # reset
                continue

            if values["-PORTFOLIO_MODE-"]:
                selected_strategy = values["-STRATEGY_SELECT-"]
            else:
                selected_strategy = "-SINGLE_MODE-"

            # Save current settings for the selected strategy
            if selected_strategy not in strategy_settings:
                strategy_settings[selected_strategy] = {}
            update_strategy_settings(values, strategy_settings[selected_strategy])

            # Validate settings for all strategies
            result = validate_strategy_settings(strategy_settings)
            if type(result) == str:
                # there was an error
                sg.popup_no_border(result)
                continue

            start_date_str = values["-START_DATE-"]
            end_date_str = values["-END_DATE-"]
            if start_date_str:
                try:
                    start_date = parser.parse(start_date_str, fuzzy=True).date()
                except ValueError:
                    sg.popup_no_border(
                        "Problem parsing Start Date.\nTry entering in YYYY-MM-DD format"
                    )
                    continue
            else:
                start_date = None
            if end_date_str:
                try:
                    end_date = parser.parse(end_date_str, fuzzy=True).date()
                except ValueError:
                    sg.popup_no_border(
                        "Problem parsing End Date.\nTry entering in YYYY-MM-DD format"
                    )
                    continue
            else:
                end_date = None

            # All settings validated, proceed with analysis
            window["-PROGRESS-"].update(visible=True)
            window["Analyze"].update("Working...", disabled=True)
            window["Cancel"].update(visible=True)
            threading.Thread(
                target=lambda: run_analysis_threaded(
                    files_list,
                    strategy_settings,
                    values["-OPEN_FILES-"],
                ),
                daemon=True,
            ).start()
            test_running = True

            save_settings(app_settings, settings_filename, values)

        elif event == "Browse":
            files = sg.popup_get_file(
                "",
                file_types=(("CSV Files", "*.csv"),),
                multiple_files=True,
                no_window=True,
                files_delimiter=";",
            )
            if not files:
                # user hit cancel
                continue

            if type(files) == tuple:
                file_str = ";".join(files)
            else:
                file_str = files
            window["-FILE-"].update(file_str)

            strategy_settings.clear()  # reset strategy settings
            if values["-PORTFOLIO_MODE-"]:
                strategies = [os.path.basename(file) for file in file_str.split(";")]
                window["-STRATEGY_SELECT-"].update(values=strategies)
                if strategies:
                    # select the first strategy in the list
                    window["-STRATEGY_SELECT-"].update(value=strategies[0])

            else:
                strategies = ["-SINGLE_MODE-"]
                window["-STRATEGY_SELECT-"].update(values=[])

            # Initialize settings for each strategy
            for strategy in strategies:
                strategy_settings[strategy] = {}
                update_strategy_settings(values, strategy_settings[strategy])
                # set the portfolio weightings to equal weight
                strategy_settings[strategy]["-PORT_WEIGHT-"] = 100 / len(strategies)
                window["-PORT_WEIGHT-"].update(
                    format_float(strategy_settings[strategy]["-PORT_WEIGHT-"])
                )

            # We must continue so the GUI does not update with old values from the values dict
            continue

        elif event == "-PORTFOLIO_MODE-":
            portfolio_mode = values["-PORTFOLIO_MODE-"]
            for key in [
                "-STRATEGY_SELECT-",
                "-PASSTHROUGH_MODE-",
                "-PORT_WEIGHT_TEXT1-",
                "-PORT_WEIGHT-",
                "-PORT_WEIGHT_TEXT2-",
            ]:
                window[key].update(visible=portfolio_mode)

            if portfolio_mode:
                files = values["-FILE-"].split(";")
                strategies = [os.path.basename(file) for file in files]
                window["-STRATEGY_SELECT-"].update(values=strategies)
                if strategies:
                    # select the first strategy in the list
                    window["-STRATEGY_SELECT-"].update(value=strategies[0])
            else:
                strategies = ["-SINGLE_MODE-"]

            # Initialize settings for each strategy
            strategy_settings.clear()
            for strategy in strategies:
                strategy_settings[strategy] = {}
                update_strategy_settings(values, strategy_settings[strategy])
                # set the portfolio weightings to equal weight
                strategy_settings[strategy]["-PORT_WEIGHT-"] = 100 / len(strategies)
                window["-PORT_WEIGHT-"].update(
                    format_float(strategy_settings[strategy]["-PORT_WEIGHT-"])
                )

        elif event == "-STRATEGY_SELECT-":
            selected_strategy = values["-STRATEGY_SELECT-"]
            if selected_strategy in strategy_settings:
                for key, value in strategy_settings[selected_strategy].items():
                    if key in window.AllKeysDict:
                        # print(f"updating key: {key} value: {value}")
                        window[key].update(format_float(value))

        elif event == "__TIMEOUT__":
            if chart_images:
                # Resize the image and update the element
                window_w, window_h = window.size
                image_width_max = int(window_w * 0.90)
                image_height_max = int(window_h * 0.45)
                image_width = min(
                    image_width_max, int(image_height_max / image_aspect_ratio)
                )
                image_size = (image_width, int(image_width * image_aspect_ratio))
                for chart, image_b64 in chart_images.items():
                    # we only need to pass the height
                    resized_image = resize_base64_image(image_b64, image_size[1])
                    window[chart].update(data=resized_image)

        elif event == "-THEME-":
            new_theme = themes[values["-THEME-"]]
            sg.theme(new_theme)
            sg.theme_button_color(button_color)  # override button color
            save_settings(app_settings, settings_filename, values)
            # Recreate the window with the new theme
            Checkbox.clear_elements()
            new_window = get_main_window(values.copy(), window)

            # Close the current window
            window.close()

            window = new_window
            continue

        elif event == "-CALC_TYPE-":
            window["-CALC_TYPE_TEXT-"].update(values["-CALC_TYPE-"])

        # Update strategy settings when values change but not while analysis is running
        if (
            values["-PORTFOLIO_MODE-"]
            and values["-STRATEGY_SELECT-"]
            and not test_running
        ):
            selected_strategy = values["-STRATEGY_SELECT-"]
            update_strategy_settings(values, strategy_settings[selected_strategy])
        elif not values["-PORTFOLIO_MODE-"] and not test_running:
            if "-SINGLE_MODE-" not in strategy_settings:
                strategy_settings["-SINGLE_MODE-"] = {}
            update_strategy_settings(values, strategy_settings["-SINGLE_MODE-"])

        # check if thread is done
        while True:
            try:
                result_key, results = results_queue.get(block=False)
            except queue.Empty:
                break

            if result_key == "-RUN_ANALYSIS_END-":
                df_dicts = results
                for right_type, day_dict in df_dicts.items():
                    for day, df_dict in day_dict.items():

                        top_times_df = get_top_times(df_dict, strategy_settings)
                        table_data = top_times_df.values.tolist()
                        if right_type.endswith("Gap Up"):
                            window[
                                f"-TABLE_{right_type.removesuffix(" Gap Up")}_{"Gap Up"}_{day}-"
                            ].update(values=table_data, num_rows=len(table_data))
                        elif right_type.endswith("Gap Down"):
                            window[
                                f"-TABLE_{right_type.removesuffix(" Gap Down")}_{"Gap Down"}_{day}-"
                            ].update(values=table_data, num_rows=len(table_data))
                        else:
                            window[f"-TABLE_{right_type}_{"All"}_{day}-"].update(
                                values=table_data, num_rows=len(table_data)
                            )

                if values["-BACKTEST-"]:
                    path = os.path.join(
                        os.path.dirname(files_list[0]), "data", "trade_logs"
                    )
                    os.makedirs(path, exist_ok=True)
                    threading.Thread(
                        target=lambda: walk_forward_test(
                            df_dicts,
                            path,
                            strategy_settings,
                            initial_value=float(values["-START_VALUE-"]),
                            start=start_date,
                            end=end_date,
                            use_scaling=values["-SCALING-"],
                            export_trades=values["-EXPORT-"],
                            export_OO_sig=values["-EXPORT_OO_SIG-"],
                        ),
                        daemon=True,
                    ).start()

                else:
                    window["-PROGRESS-"].update(visible=False)
                    window["Cancel"].update(visible=False)
                    window["Analyze"].update("Analyze", disabled=False)
                    test_running = False

            elif result_key == "-BACKTEST_END-":
                window["-PROGRESS-"].update(visible=False)
                window["Cancel"].update(visible=False)
                window["Analyze"].update("Analyze", disabled=False)
                test_running = False
                check_result = True
                for result_df in results.values():
                    if result_df.empty:
                        check_result = False
                        break
                if not check_result:
                    sg.popup_no_border(
                        "One or more of your strategies or files contains no results.\nPerhaps the dataset does not go back far enough?"
                    )
                    continue
                table_data, img_data = get_pnl_plot(results)
                chart_images["-PNL_CHART-"] = img_data
                window["-PNL_TABLE_CHART-"].update(
                    values=table_data, num_rows=min(len(table_data), 4)
                )

                chart_images["-WEEKDAY_PNL_CHART-"] = get_weekday_pnl_chart(results)
                chart_images["-MONTHLY_PNL_CHART-"] = get_monthly_pnl_chart(results)
                chart_images["-NEWS_PNL_CHART-"] = get_news_event_pnl_chart(results)
                chart_images["-NEWS_AVG_PNL_CHART-"] = get_news_event_pnl_chart(
                    results, False
                )
                if values["-PORTFOLIO_MODE-"]:
                    chart_images["-CORRELATION_MATRIX-"] = get_correlation_matrix(
                        results
                    )
                    window["-CORRELATION_MATRIX_TAB-"].update(visible=True)
                # resize the images to fit in the window
                for chart, image_data in chart_images.items():
                    chart_image = resize_base64_image(
                        image_data,
                        int(window.size[1] * 0.25),
                    )
                    window[chart].update(data=chart_image)

                window["-TAB_GROUP-"].Widget.select(4)

                # recreate window to have table columns auto adjust
                new_theme = themes[values["-THEME-"]]
                sg.theme(new_theme)
                sg.theme_button_color(button_color)  # override button color

                # Recreate the window with the new theme
                Checkbox.clear_elements()
                new_window = get_main_window(values.copy(), window)

                # Close the current window
                window.close()

                window = new_window
                continue

            elif result_key == "-BACKTEST_CANCELED-":
                window["-PROGRESS-"].update(visible=False)
                window["Cancel"].update("Cancel", disabled=False, visible=False)
                window["Analyze"].update("Analyze", disabled=False)
                test_running = False

            elif result_key == "-IMPORT_NEWS-":
                sg.popup_no_border(results, auto_close=True, auto_close_duration=5)

            elif result_key == "-ERROR-":
                sg.popup_no_border(results)
        # move the progress bar
        if window["Analyze"].Disabled:
            window["-PROGRESS-"].Widget["value"] += 10
        else:
            window["-PROGRESS-"].Widget["value"] = 0

    window.close()


if __name__ == "__main__":
    main()
